
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Welcome to the next generation 5G and post 5G computing &#8212; softgrid computation package. softgrid v1.0.0</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-softgrid">
<span id="welcome-to-the-next-generation-5g-and-post-5g-computing"></span><h1>Welcome to the next generation 5G and post 5G computing<a class="headerlink" href="#module-softgrid" title="Permalink to this headline">¶</a></h1>
<p>softgrid is a resource orchestration implementation to executing any type of computation
on a grid of connected commodity hardware. It’s the perfect hybrid solution to
distributing data and computation tasks that allows maximizing data availability
and transfer speed without affecting the scalability of the performed calculation.
In a world evolving towards extremely low latency and fast data transfer rate
network infrastructures <strong>(e.g. 5G and post 5G)</strong> and abundance of computation
resources availability, applications should be enabled to take advantage of such
infrastructure and tailor the required performance. softgrid is a very powerful
and light weight implementation that allows creating any soft grid structure
of executors on any connected grid of computation hardware (local and remote)
without the need to configure or install any piece of software on local or
remote machines. softgrid is very flexible to the point where any computation
graph can be created in short and razor sharp softgrid api calls.</p>
<p>Implementations like softgrid, are the only hope to enable third party entities to
leverage and use complex networks <strong>(5G and post 5G)</strong> with minimal implementation
that can be developed on local and personal machines and then indefinitely
expanded to the global network without touching a line of code or having to
install any piece of software on remote network machines.</p>
<p>softgrid also allows performing embarrassingly parallel independent computations
as well as synchronous and asynchronous type of computations on the grid
workers. No need to mention that traditional map-reduce jobs are also possible
and performed at a breeze</p>
<p>softgrid is not a rigid software infrastructure even at runtime. A user can
scale up and down and change the structure of the grid by lunching or
disconnecting and shutting down executors or machines.</p>
<p>Finally, softgrid can be used without any effort on any cloud infrastructure
and leverage the scalability of the resources real time.</p>
<div class="section" id="nomenclature">
<h2>Nomenclature:<a class="headerlink" href="#nomenclature" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p><strong>Orchestrator:</strong> This is the main executor of the grid and it has to be
launched to create the grid. <em>ORCHESTRATOR PROCESS IS NOT SUPPOSED TO RUN
HEAVY COMPUTATIONS BUT SHOULD BE USED FOR GRID TRANSACTION PURPOSES</em></p></li>
<li><p><strong>Router:</strong> This is a simple routing executor that is used to split and
bifurcate the grid and create multiple grid branches and nodes. <em>ROUTER
PROCESS IS NOT SUPPOSED TO RUN HEAVY COMPUTATIONS BUT SHOULD BE USED
FOR GRID TRANSACTION PURPOSESS</em></p></li>
<li><p><strong>Manager:</strong> This is the executor that manages workers. A manager and its
workers are supposed to be running on the same physcial machine. <em>MANAGER
PROCESS IS NOT SUPPOSED TO RUN HEAVY COMPUTATIONS BUT SHOULD BE USED FOR
GRID TRANSACTION PURPOSES</em></p></li>
<li><p><strong>Worker:</strong> This is the worker of the grid where heavy computations should be
made.</p></li>
<li><p><strong>gridUniqueName:</strong> Every executor when launched and connected to the grid
will get attributed its own and unique grid name which can be accessed using
gridUniqueName property of the executor instance.
A gridUniqueName is afterall a formatted string of the following
format: “role|name&#64;address[pid]:port” where role is the executor type
(orchestrator, router, manager, etc.), name is the executor name given by
the user upon instanciation, address is the machine ip address, pid is
the process id on the machine and port is the port of communication between
the executor and its upgrid. When allowed, an executor can transfer data
to a target executor on the grid using the target gridUniqueName.</p></li>
<li><p><strong>upgrid &amp; downgrid:</strong> An executor (let’s call it A) is connected to
the grid through another grid executor (let’s call it B). In this case B
is the upgrid of A because it connects A to the grid and it’s one executor
or one transfer step closer to the orchestrator than A. Every connected
executor has a unique upgrid except the Orchestrator that has no upgrid
because it’s the main entry to the grid. Keeping the same logic, A is a
downgrid of B because because it’s one executor or one transfer step away
from the orchestrator than B. Except for workers that are the end point
of the grid and have no downgrids, executors can have more than one downgrid
but always one upgrid.</p></li>
<li><p><strong>bridge:</strong> A bridge is a special direct connection between grid distant
executors.</p></li>
<li><p><strong>gridPath:</strong> Every executor has it’s own gridPath that is a list of all
directly connected executors gridUniqueName from the orchestrator to
the executor itself.</p></li>
</ol>
</div>
<div class="section" id="usage">
<h2>Usage:<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic simple">
<li><p>On local machine to scale up computations</p></li>
<li><p>On cloud services to leverage hexa-scale computation</p></li>
<li><p>By IOT devices connected to fast network <strong>(5G and post 5G)</strong> to get fast
response upon tasks that require heavy computations or on demand distributed
data availability</p></li>
</ol>
</div></blockquote>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/grid_usage.png"><img alt="_images/grid_usage.png" src="_images/grid_usage.png" style="width: 900px; height: 500px;" /></a>
<p class="caption"><span class="caption-text">A softgrid grid instance is hardware independant and realtime size adjustable.
Using softgrid, connected IOT devices can communicate with the network towers
to perform swift low latency computations while getting and pushing updates
and computations to cloud services, at home personal devices or to a
business data center. For heaving computation demanding tasks, grid nodes
and connection bridges can be created and later on decommissioned and
destroyed as needed.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<hr class="docutils" />
<dl class="py function">
<dt id="softgrid.get_version">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s version number.</p>
</dd></dl>

<dl class="py function">
<dt id="softgrid.get_author">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_author</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_author" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s author’s name.</p>
</dd></dl>

<dl class="py function">
<dt id="softgrid.get_email">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_email</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_email" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s author’s email.</p>
</dd></dl>

<dl class="py function">
<dt id="softgrid.get_doc">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_doc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s official online documentation link.</p>
</dd></dl>

<dl class="py function">
<dt id="softgrid.get_repository">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_repository</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_repository" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s official online repository link.</p>
</dd></dl>

<dl class="py function">
<dt id="softgrid.get_pypi">
<code class="sig-prename descclassname">softgrid.</code><code class="sig-name descname">get_pypi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#softgrid.get_pypi" title="Permalink to this definition">¶</a></dt>
<dd><p>Get softgrid’s pypi link.</p>
</dd></dl>

</div>
<div class="section" id="softgrid-globals">
<h2>softgrid.Globals<a class="headerlink" href="#softgrid-globals" title="Permalink to this headline">¶</a></h2>
<p>softgrid Globals contains all softgrid main global variables including default
and machine specific rules.</p>
<p>The easiest way to alter the grid rules is by updating Globals.RULES prior to
intializing the Orchestrator.</p>
<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Globals.</code><code class="sig-name descname">Logger</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pysimplelog.SimpleLog.SingleLogger</span></code></p>
<p>This will work across the whole application on all machines</p>
<dl class="py method">
<dt>
<code class="sig-name descname">custom_init</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Custom initialize abstract method. This method will be called  at the end of
initialzation. This method needs to be overloaded to custom initialize
Logger instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>*args (): This is used to send non-keyworded variable length argument
list to custom initialize.</p></li>
<li><p>**kwargs (): This is keyworded variable length of arguments.
kwargs can be anything other than __init__ arguments.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">softgrid_log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logType</span></em>, <em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">gridUniqueName</span><span class="o">=</span><span class="default_value">'role:name&#64;address'</span></em>, <em class="sig-param"><span class="n">utcTime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tback</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="softgrid-core">
<h2>softgrid.Core<a class="headerlink" href="#softgrid-core" title="Permalink to this headline">¶</a></h2>
<p>softgrid Core module contains all executors base implementations and definitions.</p>
<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">GridBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">killAtDisconnect</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>GridBase declares and handles all general properties of the excutor.
Some of the defined properties are only defined in GridBase but must be
handled in GridBase children. All os signal hadlers are defined
in GridBase. GridBase instanciation is forbidden.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>killAtDisconnect (None, Boolean): whether to kill process upon calling
disconnect with kill parameters passed as None.
and passed kill argument to the called disconnect method is None,
then kill will be set to session killAtDisconnect boolean value
and if the latter is None then it will be set to True
if session is not interactive</p></li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isDisconnected</code></dt>
<dd><p>Whether the excutor was disconnected</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">killAtDisconnect</code></dt>
<dd><p>return killAtDisconnect flag value</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">applicationName</code></dt>
<dd><p>Application name</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">gridPath</code></dt>
<dd><p>Grid path to get to this object for Orchestrator</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">gridUniqueName</code></dt>
<dd><p>grid executor grid unique name</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">role</code></dt>
<dd><p>Excuctor role which can be Orchestrator, Router, Manger, etc.</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">pid</code></dt>
<dd><p>Process id</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">address</code></dt>
<dd><p>Machine address</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">port</code></dt>
<dd><p>Executor communication port number</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">portFetch</code></dt>
<dd><p>Whether to smartly fetch for available port</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">password</code></dt>
<dd><p>Server communication password</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">name</code></dt>
<dd><p>Executor name given by user</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">softgridVersion</code></dt>
<dd><p>get softgrid used version</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">uniqueName</code></dt>
<dd><p>Unique name given to all grid base instances upon instanciation</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">UTCStartTime</code></dt>
<dd><p>Executor instantiation time</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">startDateTime</code></dt>
<dd><p>Executor instantiation date time</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">passwords</code></dt>
<dd><p>Dictionary copy of downgrid executors server password.
e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;managers&#39;</span><span class="p">:</span> <span class="p">{},</span>
 <span class="s1">&#39;routers&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;router|Router@135.210.224.198[1234]:5002&#39;</span><span class="p">:</span> <span class="s1">&#39;d3656182-a486-11e8-846c-f45c89c22ebf&#39;</span><span class="p">,</span>
             <span class="s1">&#39;router|Router@emote.machine.com[1235]:5000&#39;</span><span class="p">:</span> <span class="s1">&#39;f206112c-a486-11e8-9cf5-fa163ecc0309&#39;</span><span class="p">},</span>
 <span class="s1">&#39;workers&#39;</span><span class="p">:</span> <span class="p">{}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">paths</code></dt>
<dd><p>Copy of executors grid unique path.
e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;manager&#39;</span><span class="p">:</span> <span class="p">{},</span>
 <span class="s1">&#39;router&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;router|Router@135.210.224.198[1234]:5002&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;orchestrator|Orchestrator@135.210.224.198[1236]:5001&#39;</span><span class="p">],</span>
             <span class="s1">&#39;router|Router@emote.machine.com[1235]:5000&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;orchestrator|Orchestrator@135.210.224.198[1236]:5001&#39;</span><span class="p">]},</span>
 <span class="s1">&#39;worker&#39;</span> <span class="p">:</span> <span class="p">{}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">routers</code></dt>
<dd><p>Downgrid routers grid unique name sorted by ‘downgrid_acknowledge_utctime’</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">managers</code></dt>
<dd><p>Downgrid managers grid unique name sorted by ‘downgrid_acknowledge_utctime’</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">workers</code></dt>
<dd><p>Downgrid workers grid unique name sorted by ‘downgrid_acknowledge_utctime’</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">kill</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Abruptly Kill executor by sending os kill signal. Calling kill
result in forcefully stopping current process python execution and all
executor’s downgrid will disconnect from grid. Unline disconnect, no
cleanup will be made upon calling kill. All temporary files must be
later manually removed. Better to always call disconnect before kill</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">disconnect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kill</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">killLocalDowngrids</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Disconnect executor from grid. All downgrids will be disconnected as
well and those running on the same machine will be terminated with
an os kill signal automatically if killLocalDowngrids is set to
True. If running in non-interactive mode, an executor will kill itself
upon disconnecting from grid. Interactive mode is True if executor is
launched from a user terminal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>kill (None, Boolean): whether to kill process. If None is given
then kill will be set to session killAtDisconnect boolean value
and if the latter is None then it will be set to True
if session is not interactive</p></li>
<li><p>killLocalDowngrids (boolean): whether to os signal kill
locally running downgrids</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">log_and_transfer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logType</span></em>, <em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">tback</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Template method to log and transfer logging to upgrid chain. Calling
this template will result in printing log message and traceback to
standard output only. Full log and transfer implementation is defined
in TransferBase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>logType (string): the log type e.g. info</p></li>
<li><p>message (string): the log message</p></li>
<li><p>tback (None, str): the log traceback</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_to_executor_and_log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">receiver</span></em>, <em class="sig-param"><span class="n">logType</span></em>, <em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">tback</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>This is a template method that is meant to transfer a certain log
to a different executor and start the logging chain at that executor.
This template implementation will simply call ‘log_and_transfer’
and it is overloaded in TransferBase</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receiver (string): executor grid unique name to transfer log to</p></li>
<li><p>logType (string): the log type e.g. info</p></li>
<li><p>message (string): the log message</p></li>
<li><p>tback (None, str): the log traceback</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">split_grid_unique_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gridUniqueName</span></em><span class="sig-paren">)</span></dt>
<dd><p>Split grid unique name into its different components. Raises an error
if provided grid unique name is not formatted right.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>gridUniqueName (str): grid unique name</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>role (str): grid executor role</p></li>
<li><p>name (str): grid executor name</p></li>
<li><p>address (str): grid executor machine address</p></li>
<li><p>pid (int): grid executor machine process PID</p></li>
<li><p>port (int): grid executor server machine assigned port</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add object to grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): object name</p></li>
<li><p>obj (dict, string): object in string dumps format or a dictionary
of ‘object’ key and string dumps format value and ‘loads’ key
with loads module name ‘cPickle’,’pickle’ or ‘dill’</p></li>
<li><p>replace (boolean): Whether to replace data when existing</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Operation success or failure
status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">serialize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get object from grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): object name</p></li>
<li><p>default (object): default object to return in case data does not
exist</p></li>
<li><p>serialize (boolean): whether to serialize object prior to returning</p></li>
<li><p>mustExist (boolean): whether object name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>object (object, Collections.SoftgridStatus): object defined under
given name. If failed, SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">pop_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">serialize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return object from grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): object name</p></li>
<li><p>default (object): default value to return in case object does not
exist</p></li>
<li><p>serialize (boolean): whether to serialize prior to returning</p></li>
<li><p>mustExist (boolean): whether object name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>object (object, Collections.SoftgridStatus): poped object defined
under given name. If failed, SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add data to grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): data name</p></li>
<li><p>data (object): data object</p></li>
<li><p>replace (boolean): Whether to replace data when existing</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Operation success or failure
status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get data from grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): data name</p></li>
<li><p>default (object): default value to return in case data does not
exist</p></li>
<li><p>mustExist (boolean): whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object, Collections.SoftgridStatus): Data object defined
under given name. If failed, SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">pop_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return data from grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): data name</p></li>
<li><p>default (object): default value to return in case data does not
exist</p></li>
<li><p>mustExist (boolean): whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object, Collections.SoftgridStatus): Poped data object
defined under given name. If failed, SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">root</span><span class="o">=</span><span class="default_value">'temporary'</span></em>, <em class="sig-param"><span class="n">writeFunc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wkwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">readFunc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add file to machine local drive given a reference name, path, data,
write and read functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): file name to refer to during execution.</p></li>
<li><p>path (string): relative path to given root in local machine to
write file</p></li>
<li><p>data (None, object): file data to write to disk using writeFunc
or open(path).write mehtod. If None is given, then a file in
absolute path must exist. Setting data to None is used to add
file to multiple executors in the same machine.</p></li>
<li><p>root (None, str): root of path to where to write the file. If None
then given path is absolute. Otherwise it must be either ‘’ which
is equivalent to None or ‘temporary’ or ‘permanent’ so data path
will be relative to respectively temporary or permanent directory.</p></li>
<li><p>writeFunc (None, str, dict, callable): writing file function.
if given, first argument must be the data and the second
argument the file path.</p></li>
<li><p>wargs (None, list): write function func list of arguments</p></li>
<li><p>wkwargs (None, list): write function func dictionary of keyword arguments</p></li>
<li><p>readFunc (None, str, dict, callable): reading file function. If
given, first argument must be reserved for the file path.</p></li>
<li><p>replace (boolean): Whether to replace file when existing and all
file names pointing to the replaced file will be automatically
removed.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Operation success or failure
status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">rargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rkwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get softgrid stored file from local drive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): file name as refered to in executor.</p></li>
<li><p>rargs (None, list): read function func list of arguments</p></li>
<li><p>rkwargs (None, list): read function func dictionary of keyword
arguments</p></li>
<li><p>default (object): Default value to return in case file does not
exist</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object): File value as read using open(path).read or using
defined readFunc. If failed to getting file SoftgridStatus will
be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">pop_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">rargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rkwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">delete</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return softgrid file data from grid executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): file name as refered to in executor.</p></li>
<li><p>rargs (None, list): read function func list of arguments</p></li>
<li><p>rkwargs (None, list): read function func dictionary of keyword
arguments</p></li>
<li><p>default (object): default value to return in case file does not
exist</p></li>
<li><p>mustExist (boolean): whether data name must exist.</p></li>
<li><p>delete (boolean): whether to delete file on disk as well</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>fileParams (dictionary,  Collections.SoftgridStatus): file
parameters with ‘data’ key added. If failed, SoftgridStatus will
be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">firstArgExecutor</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add user defined function to grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): user defined function unique name to refer to.
If given func is a string definition of the function then
name must be the funtion name as defined in the func string</p></li>
<li><p>func (callable, string): Callable or function source code to
compile.</p></li>
<li><p>firstArgExecutor (boolean): Whether func first argument must be
the executor object. Executor object is remote therefore it can’t
be passed among fargs or fkwargs. This flag allows the executor
executing func to pass self as first argument to func followed
by *fargs and **fkwargs</p></li>
<li><p>replace (boolean): Whether to replace function when existing.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Operation success or failure
status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get function from grid executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): function name.</p></li>
<li><p>default (object): default value to return in case function does not
exist</p></li>
<li><p>mustExist (boolean): whether function name must exist.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>function (object): Function defined under given name. If failed,
SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">pop_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return function from grid executor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Function name</p></li>
<li><p>default (object): Default value to return in case function does
not exist</p></li>
<li><p>mustExist (boolean): Whether function name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>function (object, Collections.SoftgridStatus): poped function
defined under given name. If failed, SoftgridStatus will be returned.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">packageDict</span></em>, <em class="sig-param"><span class="n">relativeRoot</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">description</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">sitePackages</span><span class="o">=</span><span class="default_value">'temporary'</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add user defined package or module to importable definitions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>packageDict (dictionary): module or package dictionary as created
using softgrid.Collection.read_files function.</p></li>
<li><p>relativeRoot (string): name of directory (package) under which to
store the module or package files. If empty, files and directories
will be created directly under site-packages.</p></li>
<li><p>description (None, string): some description that will be used as
SoftgridStatus return name.</p></li>
<li><p>sitePackages (string): designate where to store the package. It
must be any ‘temporary’, ‘permanent’, ‘user’ or ‘memory’.</p></li>
<li><p>replace (boolean): Whether to replace package or module if existing.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Operation success or failure
status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">MachineManagement</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rules</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.GridBase</span></code></p>
<p>MachineManagement defines softgrid machines management at every executor.
It enables every deployed executor to be aware of its environment and
platform. Rules can be set for every machine and deployed softgrid executor.
If machine rules are not given, default rules will be applied automatically
from softgrid.Globals.RULES dictionary.</p>
<p>In order to customize a grid, it’s preferable to set machine rules before
launching any executor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic">
<li><p>rules (None, dict): rules and parameters given to local and remote
machines.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;machine_maximum_number_of_managers&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
 <span class="s1">&#39;machine_maximum_number_of_routers&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
 <span class="s1">&#39;machine_maximum_number_of_workers&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">machines</code></dt>
<dd><p>Copy of executor downgrid machines and softgrid executors dictionary.
e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;135.210.224.198&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;manager&#39;</span><span class="p">:</span> <span class="p">[],</span>
                     <span class="s1">&#39;machine_number_of_cpu&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                     <span class="s1">&#39;router&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;router|Router@135.210.224.198[1234]:5001&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;router|Router@135.210.224.198[1235]:5002&#39;</span><span class="p">],</span>
                     <span class="s1">&#39;worker&#39;</span><span class="p">:</span> <span class="p">[]},</span>
<span class="s1">&#39;remote.machine.com&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;manager&#39;</span><span class="p">:</span> <span class="p">[],</span>
                       <span class="s1">&#39;machine_number_of_cpu&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                       <span class="s1">&#39;router&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;router|Router@zremote.machine.com[12345]:5000&#39;</span><span class="p">],</span>
                       <span class="s1">&#39;worker&#39;</span><span class="p">:</span> <span class="p">[]}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">machineNumberOfCores</code></dt>
<dd><p>Number of cores on current machine</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">machinesAddress</code></dt>
<dd><p>Executor downgrid machines addresses list</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">rules</code></dt>
<dd><p>Copy of rules dictionary set by the executor
e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;overload_machine_rules&#39;</span><span class="p">:</span> <span class="p">{},</span>
 <span class="s1">&#39;machine_maximum_number_of_managers&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
 <span class="s1">&#39;machine_maximum_number_of_routers&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
 <span class="s1">&#39;machine_maximum_number_of_workers&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
 <span class="s1">&#39;execution_allow_negative_priority&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;execution_allow_none_priority&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;log_manager_kwargs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;logToFile&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="s1">&#39;logToStdout&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s1">&#39;stdoutMaxLevel&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
 <span class="s1">&#39;log_orchestrator_kwargs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;logFileBasename&#39;</span><span class="p">:</span> <span class="s1">&#39;softgrid_application_2019-09-26-07-41-36&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;logToFile&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="s1">&#39;logToStdout&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                             <span class="s1">&#39;stdoutMaxLevel&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
 <span class="s1">&#39;log_router_kwargs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;logToFile&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;logToStdout&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;stdoutMaxLevel&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
 <span class="s1">&#39;log_worker_kwargs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;logToFile&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;logToStdout&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;stdoutMaxLevel&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
 <span class="s1">&#39;orchestrator_allow_managers&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;orchestrator_allow_workers&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;timeout_long&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
 <span class="s1">&#39;timeout_long_multiplier&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
 <span class="s1">&#39;timeout_short&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
 <span class="s1">&#39;timeout_short_multiplier&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
 <span class="s1">&#39;transfer_collect_sleep_time&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
 <span class="s1">&#39;transport_implementation&#39;</span><span class="p">:</span> <span class="s1">&#39;multiprocessing&#39;</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_machine_rules</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get copy of machine rules given its address. Default rules are returned
if machine rules are not specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>address (str): Machine address.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>rules (dict): Copy of machine rules dictionary.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">set_machine_rules</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em>, <em class="sig-param"><span class="n">rules</span></em><span class="sig-paren">)</span></dt>
<dd><p>Set machine’s rules. If machine is already in grid chain then new rules
are tested to see if they are valid with current machine state. If not
then rules are rejected.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic">
<li><p>address (str): Machine address.</p></li>
<li><p>rules (dict): Machine new rules. Some of rules keys are:</p>
<blockquote>
<div><ul class="simple">
<li><p>machine_maximum_number_of_routers (None, integer): Maximum number of
routers allowed on machine. If None, then unlimited number of
routers can be launched on machine.</p></li>
<li><p>machine_maximum_number_of_managers (None, integer): Maximum number of
managers allowed on machine. If None, then unlimited number of
managers can be launched on machine.</p></li>
<li><p>machine_maximum_number_of_workers (None, integer): Maximum number of
workers allowed on machine. If None, then as many workers as
number of physical cpu cores on machine. If negative integer
is given then this will be substracted from machine number of
physical cpu cores.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_machine_info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get machine grid information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>address (str): Machine address.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>info (dict): Machine information dictionary.</p></li>
</ol>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_remaining_executors_allowed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get remaining allowed number of routers, managers and workers on
machine as given in this executor rules</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>address (str): Machine address.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>allowed (dict): Machine information dictionary.</p></li>
</ol>
<p>e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;number_of_routers&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
 <span class="s1">&#39;number_of_managers&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
 <span class="s1">&#39;number_of_workers&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">}</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">TransferBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.MachineManagement</span></code></p>
<p>TransferBase inherits MachineManagement and defines all transfer methods,
properties and definitions. This class defines all transfer method
that allow executors to communicate between each other and allow user to
interact with local and remote grid executors. Instanciation of this
class is forbidden</p>
<dl class="py method">
<dt>
<code class="sig-name descname">get_managers_to_workers_receivers_bounce_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get downgrids managers receivers and respective workers as bounce
list of lists</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receivers (list): List of downgrid managers grid unique names</p></li>
<li><p>bounce (list): List of lists of downgrid workers grid unique names</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_transfer_template</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">priority</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">bounce</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">promisePassword</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">returnResult</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">storeResult</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">resultName</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get transfer prefilled dictionary data template.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>func (None, str, callable): Function to execute remotely. Default
value is None but this will raise an error if not set correctly.</p></li>
<li><p>args (None, tuple, list): Function func arguments.</p></li>
<li><p>kwargs (None, tuple, list): Function func keyword arguments.</p></li>
<li><p>bounce (None, str, list): Bounce is used to bounce transfer to
multiple receiver after reaching initial receiver. This is ultimately
used to transfer to workers that are managed by the same manager.
If not None, bounce must be a list of the same length as the
normalized number of receivers. bounce list can contain None,
grid unique names of sublists of grid unique names.</p></li>
<li><p>priority (None, number): Execution queue priority.</p></li>
<li><p>promisePassword (None, str): Execution job promise password.</p></li>
<li><p>returnResult (None, str): Whether to execute function ‘func’
on remote executor and return back the result.</p></li>
<li><p>storeResult (None, str): Whether to execute function ‘func’
on remote executor and store it on local executor.</p></li>
<li><p>resultName (None, str): result handling name. If None, when
returnResult is True, returned result will not be stored but
logged instead.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>template (dict): Transfer dictionary prefilled template of all
of the following key value pairs:</p>
<ul class="simple">
<li><p>mode: transfer mode which should be ‘execute’</p></li>
<li><p>propagate_upgrid:  whether to propage to executor upgrid</p></li>
<li><p>propagate_routers: whether to propage to executor downgrid routers</p></li>
<li><p>propagate_managers: whether to propage to executor downgrid managers</p></li>
<li><p>propagate_workers: whether to propage to executor downgrid workers</p></li>
<li><p>propagate_recursive: whether to propagate all the above recursively</p></li>
<li><p>bounce_transfer: used to bounce transfer to multiple receivers</p></li>
<li><p>function: the callable function or string referencing remote executor callable attribute</p></li>
<li><p>first_argument_executor: always None</p></li>
<li><p>promise_password: the execution job promise password.</p></li>
<li><p>args: function arguments to pass to upon execution</p></li>
<li><p>kwargs: function keyword arguments to pass to upon execution</p></li>
<li><p>result_handling: dictionary of rules to handling returned value from executed function</p></li>
<li><p>priority: job priority in execution queue</p></li>
</ul>
</li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># import softgrid orchestrator</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span>

<span class="c1"># instanciate orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;some_password_12345&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># create workers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span><span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                <span class="n">executorAddress</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># define some function to transfer</span>
<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">**</span><span class="n">p</span>

<span class="c1"># get transfer template</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
                                         <span class="n">args</span><span class="o">=</span><span class="p">(),</span>
                                         <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">},</span>
                                         <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">promisePassword</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">returnResult</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">storeResult</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">resultName</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># transfer and execute on a remote worker</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span>
                       <span class="n">receivers</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                       <span class="n">collect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># print result</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1000000</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_transfer_wait_timeout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transferTimeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">multiplier</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">pathLength</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get transfer wait for response timeout calculate using a single transfer
timeout ‘transferTimeout’ and number of transfers multiplier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>transferTimeout (number): single transfer wait for result timeout</p></li>
<li><p>multiplier (number): timeout multiplier. Wait timeout is
calculated as timeout * ceil( pathLength/multiplier )</p></li>
<li><p>pathLength (None, integer): number of executor the data will
transfer to. If None is given, it’s assumed that the transfer
is going upgrid till orchestrator and therefore pathLength will
be set to len(self.gridPath)</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>timeout (number): timeout waiting time. calculated as
transferTimeout * ceil( transferPath/multiplier )</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_small_transfer_wait_timeout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pathLength</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Alias for get_transfer_wait_timeout using transferTimeout=rules[‘timeout_short’]
and multiplier=rules[‘timeout_short_multiplier’]</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_big_transfer_wait_timeout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pathLength</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Alias for get_transfer_wait_timeout using transferTimeout=rules[‘timeout_long’]
and multiplier=rules[‘timeout_long_multiplier’]</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transferKwargs</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">allowBridging</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">bounce</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">collect</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">transferTimeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">multiplier</span><span class="o">=</span><span class="default_value">9223372036854775807</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer executions across the grid using transfer keyword arguments and
a set of receivers. Bouncing from a receiver to multiple is possible
and adviseable to reduce network usage especially when bouncing is set
between a manager and its downgrid workers.
Bouncing transfers will have their transfer_unique_id changed at
the bouncer receiver to transfer_unique_id +’==&gt;’+ bounce_receiver_grid_unique_name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>transferKwargs (dict, list): dictionary of transfer arguments.
If list is given, it must be a list of dictionaries of the same
length as the normalized number of receivers.</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before. Receivers list will be
normalized and expanded whether keywords are used or not.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>allowBridging (None, boolean, list): Whether to allow using
connection bridges. If None is given, transferKwargs[‘allow_bridging’]
will be used. If list is given it must be a list of None or
boolean of the same length as the normalized number of receivers.</p></li>
<li><p>bounce (None, str, list): Bounce is used to bounce transfer to
multiple receiver after reaching initial receiver. This is ultimately
used to transfer to workers that are managed by the same manager.
If not None, bounce must be a list of the same length as the
normalized number of receivers. bounce list can contain None,
grid unique names of sublists of grid unique names.</p></li>
<li><p>collect (boolean): Whether to collect and return transfered
executions results. This will block interactivity until transfers
to all receivers are returned. If transferTimeout is not None,
collect will be constrained with the same timeout settings.
If a transfer fails, SoftgridStatus will be returned with
successful flag set to False, error attribute populated
appropriately and data attribute containing transfer kwargs
data that can be used used to resend the transfer if needed.</p></li>
<li><p>transferTimeout (None, number): transfer result return with
timeout. If None is given, then no timeout condition is set
for returned result.</p></li>
<li><p>multiplier (number, list): timeout multiplier. Wait timeout is
calculated as timeout * ceil( len(gridPath)/multiplier )</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>values (Collections.SoftgridStatus, None, list): If any error
occurs, Collections.SoftgridStatus with failure flag will be
returned. Otherwise, if collect is False, None will be returned.
If collect is True, a list of all returned values from all
receivers is returned.</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">multiprocessing</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span><span class="p">,</span> <span class="n">Globals</span>

<span class="c1"># Default settings forbid user to execute his own defined functions</span>
<span class="c1"># (UDF) on grid&#39;s routers and managers. This is meant to prevent</span>
<span class="c1"># cluttering the network and the machines with work that is only</span>
<span class="c1"># meant to be ran and managed by grid workers. In this particular</span>
<span class="c1"># case, for the sake of this example, we need to allow executing UDF</span>
<span class="c1"># and this can be done by altering some grid default rules. Those</span>
<span class="c1"># rules must be modified prior to instanciating the orchestrator</span>

<span class="c1"># Allow executing user defined functions on routers and managers</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s2">&quot;router_allow_executing_udf&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">True</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s2">&quot;manager_allow_executing_udf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Allow launching as many managers as one wants on a single machine.</span>
<span class="c1"># By default it&#39;s allowed to launch one manager by machine</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s1">&#39;machine_maximum_number_of_managers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;nopassword&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1">## launch four local routers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">routers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_router</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                      <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span>
                                      <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get routers gridUniqueName</span>
<span class="n">routers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">routers</span><span class="p">]</span>

<span class="c1">## launch four local managers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">managers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_manager</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">routers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span>
                                        <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get managers gridUniqueName</span>
<span class="n">managers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">managers</span><span class="p">]</span>

<span class="c1">## launch local workers</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">managers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                      <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1"># create a user defined function that takes the</span>
<span class="c1"># remote executor as it&#39;s first argument</span>
<span class="k">def</span> <span class="nf">get_gun</span><span class="p">(</span><span class="n">executor</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">)</span>


<span class="c1"># create transfer data using helper function get_transfer_template</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">get_gun</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># set &#39;first_argument_executor&#39; flag to true.</span>
<span class="c1"># This will tell remote executor to pass itself as the funtion first argument</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># create list of receivers which is a list of all routers, managers</span>
<span class="c1"># and workers grid unique names</span>
<span class="n">receivers</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">routers</span><span class="o">+</span><span class="n">O</span><span class="o">.</span><span class="n">managers</span><span class="o">+</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span>

<span class="c1"># transfer to receivers</span>
<span class="n">guns</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span> <span class="n">receivers</span><span class="o">=</span><span class="n">receivers</span><span class="p">,</span> <span class="n">collect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># print returned results which is a list of strings of the</span>
<span class="c1"># format timestamp --&gt; gridUniqueName</span>
<span class="nb">print</span><span class="p">(</span><span class="n">guns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">log_and_transfer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logType</span></em>, <em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tback</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">gridUniqueName</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">utcTime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transferRoute</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">logLocally</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Log and transfer log to upgrid executor recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>logType (string): The log type</p></li>
<li><p>message (string): The logging message</p></li>
<li><p>data (object): any type of data to log</p></li>
<li><p>tback (None, traceback.extract_stack): The traceback extracted
stack</p></li>
<li><p>gridUniqueName (string): Grid unique name of log initiator</p></li>
<li><p>utcTime (number): Log initial time using time.time() function</p></li>
<li><p>logLocally (boolean): Whether to log locally prior to transfer</p></li>
<li><p>transferRoute (list): should never be used other than internally</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">multiprocessing</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;nopassword&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1">## launch local workers</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                      <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                      <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1"># create a user defined function that takes the</span>
<span class="c1"># remote executor as it&#39;s first argument</span>
<span class="k">def</span> <span class="nf">log_and_get_gun</span><span class="p">(</span><span class="n">executor</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">executor</span><span class="o">.</span><span class="n">log_and_transfer</span><span class="p">(</span><span class="n">logType</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;I&#39;m logging &#39;</span><span class="si">%s</span><span class="s2">&#39; in my UDF&quot;</span><span class="o">%</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">)</span>

<span class="c1"># create transfer data</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">log_and_get_gun</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># set &#39;first_argument_executor&#39; flag to true.</span>
<span class="c1"># This will tell remote executor to pass itself as the funtion first argument</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># create list of receivers which is a list of all workers</span>
<span class="c1"># gridUniqueName</span>
<span class="n">receivers</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span>

<span class="c1"># transfer to all receivers</span>
<span class="n">guns</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span> <span class="n">receivers</span><span class="o">=</span><span class="n">receivers</span><span class="p">,</span> <span class="n">collect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># print returned results which is a list of strings of the</span>
<span class="c1"># format timestamp --&gt; gridUniqueName</span>
<span class="nb">print</span><span class="p">(</span><span class="n">guns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_to_executor_and_log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">receiver</span></em>, <em class="sig-param"><span class="n">logType</span></em>, <em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">tback</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">largs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lkwargs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer log data to a target executor then log_and_transfer from there.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receiver (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>largs (None, list, tuple): log_and_transfer remaining arguments</p></li>
<li><p>lkwargs (None, dict): log_and_transfer remaining keyword
arguments.</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">multiprocessing</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span><span class="p">,</span> <span class="n">Globals</span>

<span class="c1"># allow multiple managers on the same machine. This is not a good</span>
<span class="c1"># practice but it&#39;s ok for the sake of this example</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s1">&#39;machine_maximum_number_of_managers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;nopassword&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1">## launch six local routers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">routers</span><span class="p">,</span><span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_router</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                     <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span>
                                     <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get routers gridUniqueName</span>
<span class="n">routers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">routers</span><span class="p">]</span>

<span class="c1">## launch six local managers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">managers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_manager</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">routers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span>
                                        <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">managers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">managers</span><span class="p">]</span>

<span class="c1">## launch local workers connecting directly to orchestrator</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                      <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                      <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1"># create a user defined function that takes the</span>
<span class="c1"># remote executor as it&#39;s first argument</span>
<span class="k">def</span> <span class="nf">transfer_log_and_get_gun</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">receivers</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
    <span class="c1"># get time</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># get all workers different than this one</span>
    <span class="n">receivers</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">receivers</span> <span class="k">if</span> <span class="n">w</span><span class="o">!=</span><span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">]</span>
    <span class="c1"># select a worker to transfer and log from</span>
    <span class="n">receiver</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">receivers</span><span class="p">)</span>
    <span class="c1"># transfer and log</span>
    <span class="n">m</span> <span class="o">=</span> <span class="s2">&quot;I am &#39;</span><span class="si">%s</span><span class="s2">&#39;, transfering my log &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39; and initiate the log from there&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">receiver</span><span class="p">)</span>
    <span class="n">executor</span><span class="o">.</span><span class="n">transfer_to_executor_and_log</span><span class="p">(</span><span class="n">receiver</span><span class="o">=</span><span class="n">receiver</span><span class="p">,</span> <span class="n">logType</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
    <span class="c1"># return data</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">)</span>

<span class="c1"># create transfer data</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">transfer_log_and_get_gun</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;receivers&#39;</span><span class="p">:</span><span class="n">O</span><span class="o">.</span><span class="n">routers</span><span class="o">+</span><span class="n">O</span><span class="o">.</span><span class="n">managers</span><span class="p">})</span>

<span class="c1"># set &#39;first_argument_executor&#39; flag to true.</span>
<span class="c1"># This will tell remote executor to pass itself as the funtion first argument</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># create list of receivers which is a list of all workers</span>
<span class="c1"># gridUniqueName</span>
<span class="n">receivers</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span>

<span class="c1"># transfer to all receivers</span>
<span class="n">guns</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span> <span class="n">receivers</span><span class="o">=</span><span class="n">receivers</span><span class="p">,</span> <span class="n">collect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># print returned results which is a list of strings of the</span>
<span class="c1"># format timestamp --&gt; gridUniqueName</span>
<span class="nb">print</span><span class="p">(</span><span class="n">guns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">RequesterResponderBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.TransferBase</span></code></p>
<p>Base implementation to perform synchronous and asynchronous computations
over the grid. This is implemented using transfer request methods and
wait for request and wait for response methods.</p>
<dl class="py method">
<dt>
<code class="sig-name descname">transfer_request_to_responder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">responder</span></em>, <em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">request</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">3600</span></em>, <em class="sig-param"><span class="n">allowedResponders</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">register</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">errorRaise</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">errorLog</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer a request for a response to responder executor. This can be
used as an execution hold for synchronous or asynchronous grid
computation until a response is received from a responder grid executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>responder (string, list): responder grid unique name or a list
of responders.</p></li>
<li><p>password (string, list): request password. If a response to
request is received with wrong password it will be refused.
If responder is a list of multple items, password must be
a list of unique strings</p></li>
<li><p>request (object, list): any transferable data that is used as the
request. This can be a message or any other data that a responder
might need to answer the request. If responder is a multiple items
list, request must be a list of the same size</p></li>
<li><p>timeout (None, int, float, list): number of seconds to wait for a
response. If None is given then Globals.maxint is set. If list
is given it must be of the same size as responder</p></li>
<li><p>allowedResponders (None, string, list): allowed executors
that are allowed to respond to the given request. If None, any
executor response will be accepted as long as the password is
correct.</p></li>
<li><p>register (boolean): whether to register request for response
tracking. If False, request won’t ge registered nor tracked
for response. This is useful as a last request to responders
to stop waiting for requests.</p></li>
<li><p>errorRaise (boolean, list): whether to raise an error if when
transfering a request a error occured</p></li>
<li><p>errorLog (boolean, list): whether to log if request does
generate an error</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In this code snippet we will be performing synchronous</span>
<span class="c1"># computation between the orchestrator and a random worker.</span>
<span class="c1"># The orchestrator will launch remote_increment function on a</span>
<span class="c1"># worker. This function will instanciate a variable called</span>
<span class="c1"># totalSum increment its value by incrementValue constant and</span>
<span class="c1"># sends it back to the orchestrator as a request for response.</span>
<span class="c1"># The worker execution will block until orchestrator responds back</span>
<span class="c1"># with the response for the request. At this time the orchestrator</span>
<span class="c1"># will be waiting to receive a request from the worker</span>
<span class="c1"># using wait_for_request method. Upon receiving the request,</span>
<span class="c1"># the orchestrator will get totalSum value, increments it by</span>
<span class="c1"># incrementValue and responds it back to the worker which was doing</span>
<span class="c1"># nothing but waiting for the response back from the orchestrator.</span>
<span class="c1"># This cycle will be repeated 100 time until finally the</span>
<span class="c1"># total value is logged using log_and_transfer method.</span>


<span class="c1"># standard library imports</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">uuid</span><span class="o">,</span> <span class="nn">sys</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span>

<span class="c1"># create some funky password</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">-%H-%M-%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
<span class="n">PASSWORD</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;some_password_12345&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># create local workers</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                      <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                      <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1"># define remote function to execute at the requester side</span>
<span class="k">def</span> <span class="nf">remote_increment</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">responder</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">startValue</span><span class="p">,</span> <span class="n">incrementValue</span><span class="p">,</span> <span class="n">cycles</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">totalSum</span> <span class="o">=</span> <span class="n">startValue</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cycles</span><span class="p">):</span>
        <span class="c1"># increment total sum</span>
        <span class="n">totalSum</span> <span class="o">+=</span> <span class="n">incrementValue</span>
        <span class="c1"># send transfer for a response</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">transfer_request_to_responder</span><span class="p">(</span><span class="n">responder</span><span class="o">=</span><span class="n">responder</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">totalSum</span><span class="p">)</span>
        <span class="c1"># wait for response</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">wait_for_response</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>
        <span class="c1"># get result from responder</span>
        <span class="n">totalSum</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">password</span><span class="p">][</span><span class="s1">&#39;response&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

<span class="c1"># create function to call at orchestrator side which is the</span>
<span class="c1"># responder&#39;s side in this case. this function will transfer</span>
<span class="c1"># &#39;remote_increment&#39; to a worker and start request and respond loops</span>
<span class="k">def</span> <span class="nf">transfer_and_start_respond_to_requests</span><span class="p">(</span><span class="n">O</span><span class="o">=</span><span class="n">O</span><span class="p">):</span>
    <span class="c1"># create transfer data</span>
    <span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">remote_increment</span><span class="p">)</span>
    <span class="n">transferKwargs</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;responder&#39;</span><span class="p">:</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                <span class="s1">&#39;password&#39;</span><span class="p">:</span><span class="n">PASSWORD</span><span class="p">,</span>
                                <span class="s1">&#39;startValue&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                                <span class="s1">&#39;incrementValue&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                                <span class="s1">&#39;cycles&#39;</span><span class="p">:</span><span class="mi">100</span><span class="p">}</span>
    <span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;priority&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># transfer remote_increment to worker and start executing remotely</span>
    <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span>
               <span class="n">receivers</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
               <span class="n">collect</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1"># initiate wait for request on orchestrator</span>
    <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">stepsTime</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># wait for request of certain password</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">wait_for_request</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="n">PASSWORD</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>
        <span class="c1"># get request value and add 1</span>
        <span class="n">value</span>   <span class="o">=</span> <span class="n">request</span><span class="p">[</span><span class="n">PASSWORD</span><span class="p">][</span><span class="s1">&#39;request&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># get requester which should be the same as O.workers[-1]</span>
        <span class="n">requester</span> <span class="o">=</span> <span class="n">request</span><span class="p">[</span><span class="n">PASSWORD</span><span class="p">][</span><span class="s1">&#39;requester&#39;</span><span class="p">]</span>
        <span class="c1"># respond to requester</span>
        <span class="n">O</span><span class="o">.</span><span class="n">transfer_response_to_requester</span><span class="p">(</span><span class="n">requester</span><span class="o">=</span><span class="n">requester</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">PASSWORD</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">stepsTime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span><span class="p">)</span>
    <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># wait for all logs before logging final message</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Total request and wait for response time for </span><span class="si">%s</span><span class="s2"> back and forth cycles is </span><span class="si">%.5f</span><span class="s2"> sec. (avg/cycle </span><span class="si">%.5f</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">stepsTime</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">stepsTime</span><span class="p">))</span>
    <span class="n">O</span><span class="o">.</span><span class="n">log_and_transfer</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

<span class="c1"># execute function</span>
<span class="n">transfer_and_start_respond_to_requests</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_asynchronous_request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">requester</span></em>, <em class="sig-param"><span class="n">newResponder</span></em>, <em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">response</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer a request from one responder to another. This is must be
called at the responder side when more information is needed from another
executor responder prior to responding back to the requester. This
mechanism allows asynchronous calculation on the grid where a worker
requester halts execution waiting for a response that might travel
between multiple workers before returning back to the requester.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>requester (string, list): The original requester grid unique
name or a list or original requesters.</p></li>
<li><p>newResponder (string, list): New responder to the original
request sent by requester. Or a list of new responder of the
same size as requester list</p></li>
<li><p>password (string, list): request password or a list of passwords
if of the same size as requester list</p></li>
<li><p>response (object): Any object to transfer to the newRequester.
In general this can be the original request or an updated request</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In this code snippet we will be performing asynchronous</span>
<span class="c1"># computation between a randomly selected requester worker and</span>
<span class="c1"># the remaining of the workers as responders.</span>
<span class="c1"># The orchestrator will transfer and execute &#39;request_function&#39;</span>
<span class="c1"># at the requester side and will transfer and execute</span>
<span class="c1"># &#39;respond_function&#39; at all responders side.</span>
<span class="c1"># &#39;request_function&#39; function  will loop through all given</span>
<span class="c1"># NUMBER_OF_CYCLES request for response cycles. The request for</span>
<span class="c1"># response is set to a randomly selected a responder from the list</span>
<span class="c1"># of responders. The request received at the responder</span>
<span class="c1"># side might get transfered to multiple other responders before</span>
<span class="c1"># returning back to the requester. The execution will be waiting for</span>
<span class="c1"># all that time because of the called method &#39;wait_for_response&#39;.</span>
<span class="c1"># Once the response reaches the requester, the time to get back</span>
<span class="c1"># the response is calculated, appended to the response and the</span>
<span class="c1"># cycle loops back to send another request for response.</span>
<span class="c1"># At the responder side, where &#39;respond_function&#39; function is</span>
<span class="c1"># executed, responders are waiting for any request. Once one is</span>
<span class="c1"># received, a random number is drawn to decide whether to respond</span>
<span class="c1"># or to transfer to an asynchronous responder at a probability</span>
<span class="c1"># of ASYNCHRONOUS_PROBA. When a request is transfered more than</span>
<span class="c1"># MAX_ASYNCHRONOUS_TRANSFERS the responder will respond back to</span>
<span class="c1"># request without additional asynchronous transfers.</span>


<span class="c1"># standard library imports</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">uuid</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">random</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span><span class="p">,</span> <span class="n">Globals</span>

<span class="c1">######################### USER PARAMETERS ##########################</span>
<span class="n">MAX_ASYNCHRONOUS_TRANSFERS</span> <span class="o">=</span> <span class="mi">10</span>   <span class="c1"># maximum asynchronous request transfer per request</span>
<span class="n">ASYNCHRONOUS_PROBA</span>         <span class="o">=</span> <span class="mf">0.85</span> <span class="c1"># probability or asynchronous request transfer</span>
<span class="n">NUMBER_OF_CYCLES</span>           <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># this is the total number of requestss</span>


<span class="c1">####################### DON&#39;T TOUCH FROM HERE ######################</span>
<span class="c1">## allow machine to accept any number of workers</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s1">&#39;machine_maximum_number_of_workers&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># create some funky request password</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">-%H-%M-%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
<span class="n">PASSWORD</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

<span class="c1">######################## LAUNCHING THE GRID ########################</span>
<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;some_password_12345&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># executor kwargs used here to mute some worker grid log types</span>
<span class="n">executorKwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logKwargs&#39;</span><span class="p">:{</span><span class="s1">&#39;logTypes&#39;</span><span class="p">:{</span><span class="s1">&#39;execution_started&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;stdoutFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;fileFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span>
                                           <span class="s1">&#39;execution_finished&#39;</span><span class="p">:{</span><span class="s1">&#39;stdoutFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;fileFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span>
                                           <span class="s1">&#39;result&#39;</span><span class="p">:</span>            <span class="p">{</span><span class="s1">&#39;stdoutFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;fileFlag&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span>
                                           <span class="p">}</span>
                              <span class="p">}</span>
                  <span class="p">}</span>

<span class="c1"># create local workers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                    <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span>
                                    <span class="n">executorKwargs</span><span class="o">=</span><span class="n">executorKwargs</span><span class="p">,</span>
                                    <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1"># select random requester from the list of workers</span>
<span class="n">requester</span>  <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span>
<span class="c1"># the remaining of the workers are designated responders</span>
<span class="n">responders</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">requester</span><span class="p">]</span>

<span class="c1">################### DEFINING REQUESTER FUNCTION ####################</span>
<span class="k">def</span> <span class="nf">request_function</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">responders</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">numberfOfCycles</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numberfOfCycles</span><span class="p">):</span>
        <span class="c1"># initiate request data</span>
        <span class="n">tic</span>       <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">responder</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">responders</span><span class="p">)</span>
        <span class="n">request</span>   <span class="o">=</span> <span class="p">{</span><span class="n">step</span><span class="p">:[]}</span>
        <span class="c1"># send transfer request</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">transfer_request_to_responder</span><span class="p">(</span><span class="n">responder</span><span class="o">=</span><span class="n">responder</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
        <span class="c1"># wait for response</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">wait_for_response</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>
        <span class="c1"># get response dictionary value</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="n">password</span><span class="p">][</span><span class="s1">&#39;response&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="c1"># add total request to response time</span>
        <span class="n">response</span><span class="p">[</span><span class="s1">&#39;total_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">response</span> <span class="p">)</span>
        <span class="c1"># log and transfer cycle step finished</span>
        <span class="n">tt</span>  <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="s1">&#39;total_time&#39;</span><span class="p">]</span>
        <span class="n">ls</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="n">step</span><span class="p">])</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Finished cycle &#39;</span><span class="si">%i</span><span class="s2">&#39; in &#39;</span><span class="si">%.4f</span><span class="s2">&#39; sec. for &#39;</span><span class="si">%i</span><span class="s2">&#39; asynchronous transfers averaging &#39;</span><span class="si">%.4f</span><span class="s2">&#39; sec. per transfer&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">step</span><span class="p">,</span><span class="n">tt</span><span class="p">,</span><span class="n">ls</span><span class="p">,</span><span class="n">avg</span><span class="p">)</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">log_and_transfer</span><span class="p">(</span><span class="n">logType</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
    <span class="c1"># send final requests to stop all responders from waiting for requests</span>
    <span class="n">executor</span><span class="o">.</span><span class="n">transfer_request_to_responder</span><span class="p">(</span><span class="n">responder</span><span class="o">=</span><span class="n">responders</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="p">[</span><span class="n">password</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">responders</span><span class="p">),</span> <span class="n">request</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># return result</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1">################### DEFINING RESPONDERS FUNCTION ###################</span>
<span class="k">def</span> <span class="nf">respond_function</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">requester</span><span class="p">,</span> <span class="n">responders</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">maxAsynchronousTransfers</span><span class="p">,</span> <span class="n">asynchronousProba</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">responders</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">responders</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">wait_for_request</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>
        <span class="c1"># get request value</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">request</span><span class="p">[</span><span class="n">password</span><span class="p">][</span><span class="s1">&#39;request&#39;</span><span class="p">]</span>
        <span class="c1"># check for request to break</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;STOP&#39;</span><span class="p">:</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">log_and_transfer</span><span class="p">(</span><span class="n">logType</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Received &#39;STOP&#39; request. Exiting &#39;wait_for_request&#39; loop&quot;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">executor</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)))</span>
        <span class="c1"># if path length is bigger than 10, or random &gt; asynchronousProba then respond back to requester</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">&gt;=</span><span class="n">maxAsynchronousTransfers</span> <span class="ow">or</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">&gt;</span><span class="n">asynchronousProba</span><span class="p">:</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">transfer_response_to_requester</span><span class="p">(</span><span class="n">requester</span><span class="o">=</span><span class="n">requester</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gun</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">responders</span><span class="p">)</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">transfer_asynchronous_request</span><span class="p">(</span><span class="n">requester</span><span class="o">=</span><span class="n">requester</span><span class="p">,</span> <span class="n">newResponder</span><span class="o">=</span><span class="n">gun</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>


<span class="c1">################## TRANSER FUNCTION TO RESPONDERS ##################</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">respond_function</span><span class="p">)</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;requester&#39;</span><span class="p">:</span><span class="n">requester</span><span class="p">,</span>
                            <span class="s1">&#39;responders&#39;</span><span class="p">:</span><span class="n">responders</span><span class="p">,</span>
                            <span class="s1">&#39;password&#39;</span><span class="p">:</span><span class="n">PASSWORD</span><span class="p">,</span>
                            <span class="s1">&#39;maxAsynchronousTransfers&#39;</span><span class="p">:</span><span class="n">MAX_ASYNCHRONOUS_TRANSFERS</span><span class="p">,</span>
                            <span class="s1">&#39;asynchronousProba&#39;</span><span class="p">:</span><span class="n">ASYNCHRONOUS_PROBA</span><span class="p">}</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;priority&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="kc">None</span>
<span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span>
           <span class="n">receivers</span><span class="o">=</span><span class="n">responders</span><span class="p">,</span>
           <span class="n">collect</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1">########## TRANSER FUNCTION REQUESTER AND WAIT FOR RESULT ##########</span>
<span class="n">transferKwargs</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">get_transfer_template</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">request_function</span><span class="p">)</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;responders&#39;</span><span class="p">:</span><span class="n">responders</span><span class="p">,</span>
                            <span class="s1">&#39;password&#39;</span><span class="p">:</span><span class="n">PASSWORD</span><span class="p">,</span>
                            <span class="s1">&#39;numberfOfCycles&#39;</span><span class="p">:</span><span class="n">NUMBER_OF_CYCLES</span><span class="p">}</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;first_argument_executor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">transferKwargs</span><span class="p">[</span><span class="s1">&#39;priority&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># transfer remote_increment to worker and start executing remotely</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">transferKwargs</span><span class="p">,</span>
                    <span class="n">receivers</span><span class="o">=</span><span class="n">requester</span><span class="p">,</span>
                    <span class="n">transferTimeout</span><span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
                    <span class="n">collect</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>


<span class="c1">########################## PLOT HISTOGRAMS #########################</span>
<span class="n">cyclesTime</span>     <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_ASYNCHRONOUS_TRANSFERS</span><span class="p">)]</span>
<span class="n">firstResponder</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">responders</span><span class="p">])</span>
<span class="n">asyncResponder</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">responders</span><span class="p">])</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;total_time&#39;</span><span class="p">]</span>
    <span class="n">rt</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">cyclesTime</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
    <span class="n">firstResponder</span><span class="p">[</span><span class="n">rt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">asyncResponder</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># compute averages</span>
<span class="n">cyclesAvg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cyclesTime</span><span class="p">]</span>


<span class="c1"># plot asynchronous transfer time histogram</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cyclesAvg</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">cyclesAvg</span><span class="p">,</span> <span class="o">.</span><span class="mi">8</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of asynchronous transfers per request&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Time (sec.)&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cyclesTime</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cyclesTime</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">cyclesAvg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">))</span>

<span class="c1"># plot number of transfers per responder</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">wlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">firstResponder</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">responders</span><span class="p">)),</span> <span class="p">[</span><span class="n">firstResponder</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wlist</span><span class="p">],</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;First Responder&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">responders</span><span class="p">)),</span> <span class="p">[</span><span class="n">asyncResponder</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wlist</span><span class="p">],</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="p">[</span><span class="n">firstResponder</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wlist</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Asynchronous Responder&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Number of transfers&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wlist</span><span class="p">)),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">wlist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Responders&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="_images/transfer_asynchronous_request_1.png"><img alt="_images/transfer_asynchronous_request_1.png" src="_images/transfer_asynchronous_request_1.png" style="width: 640px; height: 480px;" /></a>
<p class="caption"><span class="caption-text">This distribution shows the average time to receive the response
for asynchronous request transfers. Y axis is the time in seconds
while the X axis the is the number of asynchronous transfers.
The numbers on top of each bar are the number of recorded requests
corresponding to the bar. e.g. 13 on top of the bar at x=5 means
that there was 13 requests that were 5 times asynchronously
transfered before reaching the requester</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="_images/transfer_asynchronous_request_2.png"><img alt="_images/transfer_asynchronous_request_2.png" src="_images/transfer_asynchronous_request_2.png" style="width: 640px; height: 480px;" /></a>
<p class="caption"><span class="caption-text">This distribution shows the number of transfers per responder. X axis
is the 9 responding workers and Y axis is the number of transfers
reaching a responder. The blue bars distribution show the number
of new requests reaching the first responder. The orange bar
distribution is the number of asynchronous request transfer
reaching the responders</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_response_to_requester</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">requester</span></em>, <em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">response</span></em>, <em class="sig-param"><span class="n">blocking</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">errorRaise</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">errorLog</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer response to a request</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>requester (string, list): requester grid unique name or a list
of requesters.</p></li>
<li><p>password (string, list): request password or a list of passwords
matching the number of requesters</p></li>
<li><p>response (object, list): the response to the request. If list, it
must be of the same length as requester list</p></li>
<li><p>errorRaise (boolean, list): whether to raise an error if
request does not exist or any other error occured while looping
responses to requesters</p></li>
<li><p>errorLog (boolean, list): whether to log if request does not
exist or any other error occured while looping responses to
requesters</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">wait_for_response</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">frequency</span><span class="o">=</span><span class="default_value">0.001</span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait loop for a response for a specific request given the request
password</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><blockquote>
<div><ol class="arabic simple">
<li><p>password (string, list): request password or list of requests
password</p></li>
<li><p>timeout (int, float, list): wait timeout or list of timeout
having the same length as password list</p></li>
<li><p>frequency (float): loop check for response frequency. This is
the sleep time between checks</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>response (dictionary): responses for requests where keys are
passwords. A succesfully received response will have
‘response_received_utctime’ value not None</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">wait_for_request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">frequency</span><span class="o">=</span><span class="default_value">0.001</span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait loop for a response for a specific request given the request
password</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><blockquote>
<div><ol class="arabic simple">
<li><p>password (string, list): request password or list of requests
password</p></li>
<li><p>timeout (int, float, list): wait timeout or list of timeout
having the same length as password list</p></li>
<li><p>frequency (float): loop check for response frequency. This is
the sleep time between checks</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>request (dictionary): dictionary of requests where keys are
passwords. A succesfully received request will have a non None
value</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">release_request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password</span></em><span class="sig-paren">)</span></dt>
<dd><p>Release sent or received request for response from this executor.
This should be used when an old request with a long timeout is no
more needed or when a response is received but no need to collect it
anymore or when a request for response password needs to be recycled.
This method will return running ‘wait_for_request’ and
‘wait_for_response’ blocking methods</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>password (string, list): request for response password. This
can be a unique string password or a list of passwords or
a list of passwords of the same length as responder list</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_release_request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gun</span></em>, <em class="sig-param"><span class="n">password</span></em><span class="sig-paren">)</span></dt>
<dd><p>Release sent or received request for response from this or remote
executors. This should be used when an old request with a long timeout
is no more needed or when a request for response password needs to be
recycled. This method will return running ‘wait_for_request’ and
‘wait_for_response’ blocking methods</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>gun (string, list): executor grid unique name or a list
of executors grid unique name.</p></li>
<li><p>password (string, list): request for response password. This
can be a unique string password or a list of passwords or
a list of passwords of the same length as responder list</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">MethodsBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.RequesterResponderBase</span></code></p>
<dl class="py method">
<dt>
<code class="sig-name descname">get_executor_grid_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gridUniqueName</span></em>, <em class="sig-param"><span class="n">transferTimeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">multiplier</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span></dt>
<dd><p>recursively fetch for executor grid path given its grid unique name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>gridUniqueName (string): executor grid unique name</p></li>
<li><p>transferTimeout (number): Transfer wait timeout</p></li>
<li><p>multiplier (number): Transfer timeout grid path length multiplier</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt># result (dictionary): Dictionary where key is the upgrid grid</dt><dd><p>unique name which located the requested grid path.
If empty then given gridUniqueName was not found and therefore
not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_add_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">bounce</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">dumps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add object to specific receivers. Object must be serializable using
cPickle, pickle or dill dumps method. After transfer, object will be
revived using cPickle, pickle or dill loads method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Object name</p></li>
<li><p>obj (object): object that must be pickle, cPickle or dill dumps able</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>bounce (None, str, list): Bounce is used to bounce transfer to
multiple receiver after reaching initial receiver. This is ultimately
used to transfer to workers that are managed by the same manager.
If not None, bounce must be a list of the same length as the
normalized number of receivers. bounce list can contain None,
grid unique names of sublists of grid unique names.</p></li>
<li><p>timeout (None, int, float): Status return timeout.
If None is given, status won’t be expected.</p></li>
<li><p>dumps (None, string): Dumps method used to serialize. It can be
‘cPickle’, ‘pickle’ or ‘dill’. When None is given ‘cPickle’ then
‘pickle’ and finally ‘dill’ are tried for a successful candiated.</p></li>
<li><p>replace (boolean): Whether to replace object when existing</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_get_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get object from specific remote receivers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Object name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>timeout (int, float): Transfer collecting object timeout.</p></li>
<li><p>default (object): Default value to return in case data does not
exist</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object): Data object defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_pop_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return object from specific remote receivers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Object name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>timeout (None, int, float): Popped object returned timeout.
If None is given, object will be popped remotely but not
needed for return.</p></li>
<li><p>default (object): Default value to return in case data does not
exist</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>object (object): Poped object defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_add_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">bounce</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add data to specific receivers. This is reserved to simple data
structures of python, numpy and pandas. If failed, to transfer for
serialization issues, transfer_add_object must be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Data name</p></li>
<li><p>data (object): Data object</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>bounce (None, str, list): Bounce is used to bounce transfer to
multiple receiver after reaching initial receiver. This is ultimately
used to transfer to workers that are managed by the same manager.
If not None, bounce must be a list of the same length as the
normalized number of receivers. bounce list can contain None,
grid unique names of sublists of grid unique names.</p></li>
<li><p>timeout (None, int, float): Status return timeout.
If None is given, status won’t be expected.</p></li>
<li><p>replace (boolean): Whether to replace data when existing</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get data from specific receivers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Data name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>timeout (None, int, float): timeout value to get data from
remote executor. If None is given, method will block
until data returned.</p></li>
<li><p>default (object): Default value to return in case data does not
exist</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object): Data object defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_pop_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return data from specific receivers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Data name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>default (object): Default value to return in case data does not
exist</p></li>
<li><p>timeout (None, int, float): Popped data returned timeout.
If None is given, object will be popped remotely but not
needed for return.</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object): Poped data object defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_add_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">firstArgExecutor</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add function to specific receivers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Function name.</p></li>
<li><p>func (object): Function object.</p></li>
<li><p>firstArgExecutor (boolean): Whether func first argument must be
the executor object. Executor object is remote therefore it can’t
be passed among fargs or fkwargs. This flag allows the executor
executing func to pass self as first argument to func followed
by *fargs and **fkwargs</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>timeout (None, int, float): Status return timeout.
If None is given, status won’t be expected.</p></li>
<li><p>replace (boolean): Whether to replace function when existing</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_get_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get data from specific receivers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): function name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>default (object): Default value to return in case function does not
exist</p></li>
<li><p>mustExist (boolean): Whether data name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>function (object): Function defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_pop_udf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">mustExist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pop and return data from specific receivers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (string): Function name</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>default (object): Default value to return in case function does not
exist.</p></li>
<li><p>timeout (None, int, float): Popped udf returned timeout.
If None is given, object will be popped remotely but not
needed for return.</p></li>
<li><p>mustExist (boolean): Whether function name must exist</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>data (object): Poped data object defined under given name</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_add_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">receivers</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">sitePackages</span><span class="o">=</span><span class="default_value">'temporary'</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rejectFiles</span><span class="o">=</span><span class="default_value">'^.*?.(so|pyd|pyc)$', '^(?![a-zA-Z_]).*$'</span></em>, <em class="sig-param"><span class="n">acceptFiles</span><span class="o">=</span><span class="default_value">'^[a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}.(py|pyx|h|c|cc|cxx|c\\\\+\\\\+|hh|H|hxx|hpp|h\\\\+\\\\+)$'</span></em>, <em class="sig-param"><span class="n">rejectFolders</span><span class="o">=</span><span class="default_value">'^\\\\..*?$', '^__pycache__$', '^docs$', '^Examples$'</span></em>, <em class="sig-param"><span class="n">acceptFolders</span><span class="o">=</span><span class="default_value">'^[a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}$'</span></em>, <em class="sig-param"><span class="n">dataFiles</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer a local package or module to remote machine site-packages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>path (string): Local machine package or module path.</p></li>
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
<li><p>timeout (None, int, float): Status return timeout.
If None is given, status won’t be expected.</p></li>
<li><p>sitePackages (string): must be any of ‘temporary’, ‘permanent’ or
‘user’</p></li>
<li><p>replace (boolean): Whether to replace package or module if existing.</p></li>
<li><p>rejectFiles (list, tuple, set): List of regular expressions when
satisfied file will be ommited. List can be empty if no rejection
conditions are needed.</p></li>
<li><p>acceptFiles (list, tuple, set): List of regular expressions where
only when any is satisfied file will be read ad returned.
List can be empty if all files can be accepted.</p></li>
<li><p>rejectFolders (list, tuple, set): List of regular expressions when
satisfied folder and its content will be ommited. List can be empty
if no rejection conditions are needed.</p></li>
<li><p>acceptFolders (list, tuple, set): List of regular expressions where
only when any is satisfied folder and its content will be walked.
List can be empty if all folders can be accepted.</p></li>
</ol>
</dd>
</dl>
<p>N.B. This is safe to transport python packages with no compiled files. In
case compile files are needed unless the remote machine has the same
hardware and compiler as the local, all non python files must be compiled
on remote machine using setup.py or other commands. In this case it’s safer
to limit transered files using the following conditions and launching
remote compilation commands.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># possible conditions are</span>
<span class="n">rejectFiles</span>   <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^.*?.(so|pyd|pyc)$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;^(?![a-zA-Z_]).*$&quot;</span><span class="p">,)</span>
<span class="n">acceptFiles</span>   <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}.(py|pyx|h|c|cc|cxx|c\+\+|hh|H|hxx|hpp|h\+\+)$&quot;</span><span class="p">,)</span>
<span class="n">rejectFolders</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\..*?$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;^__pycache__$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;^docs$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;^Examples$&quot;</span><span class="p">)</span>
<span class="n">acceptFolders</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}$&quot;</span><span class="p">,)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">AssessBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.MethodsBase</span></code></p>
<p>This method contain all methods to test grid’s performance</p>
<dl class="py method">
<dt>
<code class="sig-name descname">assess_transfer_speed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">toGUN</span></em>, <em class="sig-param"><span class="n">fromGUN</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">number</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Assess the back and forth speed of data transfer between two executor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameter</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>toGUN (string): Executor grid unique name to transfer data to</p></li>
<li><p>fromGUN (None, string): Executor grid unique name to transfer
data from. If None, this executor is used.</p></li>
<li><p>data (object): Any transferable data object to test the speed of
transfer</p></li>
<li><p>number (integer): The number of assessment transfers to get a
statistical answer</p></li>
<li><p>timeout (number): timeout per transfer iteration</p></li>
<li><p>plot (boolean): whether to plot results</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>assessment (list, Collections.SoftgridStatus): Speed test
assessment result list or a Collections.SoftgridStatus if an error
happened</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">multiprocessing</span>

<span class="c1"># import softgrid orchestrator</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span>

<span class="c1"># parameters</span>
<span class="n">NUMBER</span>     <span class="o">=</span> <span class="mi">20</span>                    <span class="c1"># number of transfer cycles to get a statistical representation</span>
<span class="n">NO_DATA</span>    <span class="o">=</span> <span class="kc">None</span>                  <span class="c1">#            (16 bytes)</span>
<span class="n">TINY_DATA</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">))</span>  <span class="c1"># 1000,000   (37 MB)</span>
<span class="n">SMALL_DATA</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10000000</span><span class="p">))</span> <span class="c1"># 10,000,000 (370 MB)</span>
<span class="n">BIG_DATA</span>   <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">50000000</span><span class="p">))</span> <span class="c1"># 50,000,000 (1.85 GB)</span>

<span class="c1"># instanciate orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;some_password_12345&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># create workers</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span><span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                 <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                 <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1">## ASSESS FROM ORCHESTRATOR TO WORKER WHICH IS A DIRECT PATH</span>
<span class="c1"># assess no data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">NO_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess tiny data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">TINY_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess small data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">SMALL_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess big data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">BIG_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>


<span class="c1">## ASSESS FROM WORKER TO ANOTHER WHICH IS A 2 STEPS PATH</span>
<span class="c1"># assess no data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">NO_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess tiny data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">TINY_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess small data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">SMALL_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="c1"># assess big data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">assess_transfer_speed</span><span class="p">(</span><span class="n">toGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fromGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">BIG_DATA</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id4">
<a class="reference internal image-reference" href="_images/assess_transfer.png"><img alt="_images/assess_transfer.png" src="_images/assess_transfer.png" style="width: 950px; height: 1250px;" /></a>
<p class="caption"><span class="caption-text">Transfer speed between two different executors on the grid. Left
column plots show speed of transfer between two executors that are
one transfer step away because they are directly connected one to
another. The right side column plots show the speed of transfer
between two executors that are two transfer steps away because they
are seperated by a third executor on the grid.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">visualize_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Visualize the grid graph as seen from the calling executor. This helper
method will call softgrid.Collections.GridGraph.draw_graph method and return
any data this method returns. All given arguments (*args) and keyword
arguments (**kwargs) will be passed and used in draw_graph method.
The grid graph visual shape and executors positions in the canvas is
not guaranteed nor reproducable but the visualization respects all
connections and executors role and count. Calling this function multiple
time in a row will give different graph shapes but they are all the
same and representative of the grid structure and executors connections.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="_images/visualize_grid.png"><img alt="_images/visualize_grid.png" src="_images/visualize_grid.png" style="width: 1050px; height: 650px;" /></a>
<p class="caption"><span class="caption-text">Graph visualization of a grid as seen from the Orchestrator.
This grid instance consists of the Orchestrator along with 15
router, 35 manager and 160 worker.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">LaunchBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.AssessBase</span></code></p>
<p>In this class all remote and local launch definitons are implemented.</p>
<dl class="py method">
<dt>
<code class="sig-name descname">launch_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executorAddress</span></em>, <em class="sig-param"><span class="n">executorType</span></em>, <em class="sig-param"><span class="n">executorKwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">upgridUniqueName</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">machineUser</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">machineExecutable</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">retry</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span></dt>
<dd><p>Launch and connected executor tothe grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>executorAddress (string, list): address where executor
will be launched. If list is given it must be a list
if executor addresses</p></li>
<li><p>executorType (string, list): Executor type to launch. If
list is given, must have the same size as executorAddress
and all items must be strings of executor type</p></li>
<li><p>executorKwargs (None, dict, list): Executor instanciation
keyword arguments.  If None, all default keyword arguments
will be used. If list is given, must have the same size as
executorAddress</p></li>
<li><p>upgridUniqueName (None, string, list): Launched router
upgrid unique name. If None is given, it’s then replaced
with current executor grid unique name. If list is given,
must have the same  size as executorAddress</p></li>
<li><p>machineUser (string, list): Executor machine user name.
If list is given, must have the same size as executorAddress</p></li>
<li><p>machineExecutable (None, string, list): Python machine
executable path or alias. If None is given, or a None item
is given in the list then it’s replaced with registered
grid machines executable path if machine is registered or
simply ‘python’ alias.</p></li>
<li><p>timeout (number): timeout for launching routers. If exceeded
remaining not regiestered routers will forcefully fail to
launch.</p></li>
<li><p>retry (integer): the number of time to retry launching
executor if failure happens</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Status of success or failure</p></li>
<li><p>successful (list): list of launch parameters dictionnaries
of all successfully launched executors. Dictionaries keys
are ‘executorType’, ‘upgridUniqueName’, ‘gridUniqueName’,
‘executorAddress’, ‘machineUser’ and ‘machineExecutable’</p></li>
<li><p>failed (list): list of launch parameters dictionnaries
of all executors that failed to launch. The same parameters
can be used to relaunch the executors.  Dictionaries keys
are ‘executorType’, ‘upgridUniqueName’, ‘executorAddress’,
‘machineUser’ and ‘machineExecutable’</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span><span class="p">,</span> <span class="n">Globals</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;nopassword&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1">## launch four local routers</span>
<span class="n">status</span><span class="p">,</span> <span class="n">routers</span><span class="p">,</span><span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_router</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                     <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span>
                                     <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">launch_router</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>alias to ‘launch_executor’ with executor type as ‘Router’</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">launch_manager</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>alias to ‘launch_executor’ with executor type as ‘Manager’</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">launch_worker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>alias to ‘launch_executor’ with executor type as ‘Worker’</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">ExecutorBase</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">applicationName='softgrid_application'</em>, <em class="sig-param">address=None</em>, <em class="sig-param">port=5000</em>, <em class="sig-param">portFetch=True</em>, <em class="sig-param">password=&lt;function ExecutorBase.&lt;lambda&gt;&gt;</em>, <em class="sig-param">allowExecutingUDF=None</em>, <em class="sig-param">relaunch=True</em>, <em class="sig-param">acceptRouters=True</em>, <em class="sig-param">acceptManagers=True</em>, <em class="sig-param">acceptWorkers=True</em>, <em class="sig-param">temporaryDir=None</em>, <em class="sig-param">permanentDir=None</em>, <em class="sig-param">ddfsDir=None</em>, <em class="sig-param">logKwargs=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.LaunchBase</span></code></p>
<p>This is the former definition of all softgrid executors. This can be launched
on a remote machine as well as on local. Orchestrator, Router, Manager and
Worker implementations all inhert ExecutorBase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>name (None, string): grid executor name. If None, name will be set
to the executor class name</p></li>
<li><p>applicationName (string): Application name</p></li>
<li><p>address (None, string): Machine address. If None, then it will get
automatically assigned the ip address of the local machine</p></li>
<li><p>port (integer): The port number of the object server</p></li>
<li><p>portFetch (boolean): Whether to fetch for open port in case given
port is not available</p></li>
<li><p>password (callable, string): grid executor server communication password</p></li>
<li><p>allowExecutingUDF (boolean): Whether to allow executing user defined
function by this grid executor exxecution</p></li>
<li><p>acceptRouters (boolean): Whehter to accept router downgrid</p></li>
<li><p>acceptManagers (boolean): Whehter to accept manager downgrid</p></li>
<li><p>acceptWorkers (boolean): Whehter to accept worker downgrid</p></li>
<li><p>rules (None, dict): Machine default rules</p></li>
<li><p>logKwargs (None, dict): Logger keyword arguments</p></li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">heartMonitorFrequency</code></dt>
<dd><p>Heart beats monitor checking frequency</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">heartbeatTolerance</code></dt>
<dd><p>Heart beats monitor missing tolerance time</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">relaunch</code></dt>
<dd><p>Get relaunch flag or integer value</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">executorsTransport</code></dt>
<dd><p>Executors transport instance</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isOrchestrator</code></dt>
<dd><p>Whether this is an orchestrator</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isRouter</code></dt>
<dd><p>Whether this is an router</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isManager</code></dt>
<dd><p>Whether this is an manager</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isWorker</code></dt>
<dd><p>Whether this is an worker</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">allowExecutingUDF</code></dt>
<dd><p>Whether It’s allowed to execute user defined functions</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">machineProperties</code></dt>
<dd><p>Get machine properties dictionary</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">softgridProperties</code></dt>
<dd><p>Get softgrid properties dictionary</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">executorProperties</code></dt>
<dd><p>Get executor properties dictionary</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">acceptRouters</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">acceptManagers</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">acceptWorkers</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">destroy_bridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bridgeToGUN</span></em>, <em class="sig-param"><span class="n">bridgePassword</span></em><span class="sig-paren">)</span></dt>
<dd><p>Destroy connection bridge to bridgeToGUN</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>bridgeToGUN (string): Executor grid unique name to destroy connection
bridge to.</p></li>
<li><p>bridgePassword (string): Connection bridge password.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Status of success or failure</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">build_bridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bridgeToGUN</span></em>, <em class="sig-param"><span class="n">bridgeFromGUN</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span></dt>
<dd><p>Build connection bridge from bridgeFromGUN to bridgeToGUN</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>bridgeToGUN (string): Grid unique name of the executor to build
the connection bridge to.</p></li>
<li><p>bridgeFromGUN (None, string): Grid unique name of the executor
to build the connection bridge from.</p></li>
<li><p>timeout (number): Timeout parameter to build the bridge</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (Collections.SoftgridStatus): Status of success or failure</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Collections</span><span class="p">,</span> <span class="n">Orchestrator</span><span class="p">,</span> <span class="n">Globals</span>

<span class="c1">## allow machine to accept any number of managers</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s1">&#39;machine_maximum_number_of_managers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">## allow machine to accept any number of workers</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">RULES</span><span class="p">[</span><span class="s1">&#39;machine_maximum_number_of_workers&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">None</span>

<span class="c1">## launch orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;nopassword&#39;</span><span class="p">)</span>

<span class="c1">## launch 3 managers attached to orchestrator</span>
<span class="n">status</span><span class="p">,</span><span class="n">managers</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_manager</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                     <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
                                     <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">,</span>
                                     <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># get managers gridUniqueName</span>
<span class="n">managers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">managers</span><span class="p">]</span>

<span class="c1">## launch 5 workers on attached to each manager for a total of 15 workers</span>
<span class="n">status</span><span class="p">,</span><span class="n">workers</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">managers</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span>
                                   <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">managers</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span>
                                   <span class="n">machineUser</span><span class="o">=</span><span class="s1">&#39;some_user&#39;</span><span class="p">,</span>
                                   <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># get workers gridUniqueName</span>
<span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;gridUniqueName&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">]</span>

<span class="c1">## build connection bridges between workers</span>
<span class="n">O</span><span class="o">.</span><span class="n">build_bridge</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span>
<span class="n">O</span><span class="o">.</span><span class="n">build_bridge</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="n">O</span><span class="o">.</span><span class="n">build_bridge</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
<span class="n">O</span><span class="o">.</span><span class="n">build_bridge</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>

<span class="c1">## visualize grid graph as seen from orchestrator</span>
<span class="n">O</span><span class="o">.</span><span class="n">visualize_grid</span><span class="p">(</span><span class="n">labelsFormat</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{role}</span><span class="se">\n</span><span class="s1">$</span><span class="si">{pid}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="_images/build_bridge.png"><img alt="_images/build_bridge.png" src="_images/build_bridge.png" style="width: 950px; height: 550px;" /></a>
<p class="caption"><span class="caption-text">Grid graph as seen from Orchestrator. Grid Executors are visualized
as spheres color coded by role (red:orchestrator, blue:manager,
yellow:worker). Grid connections are drawn with solid black line
while connection bridges are drawn with the dotted red line.
e.g. without the bridge, transfer from worker15748 to worker15753
will first go through manager15730 to orchestrator15727 to
manager15729 before reaching destination. The bridge connection
built between worker15748 and worker15753 shortcuts all intermediate
grid executors. This is very useful when two executors are
expected to exchange and transfer frequently</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">connect_to_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em>, <em class="sig-param"><span class="n">port</span></em>, <em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">handshakeTrackingKey</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">blocking</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">20</span></em><span class="sig-paren">)</span></dt>
<dd><p>Connect executor to another on the grid. This will raise
an error if this executor is already connected to the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>address (str): grid server machine address this grid executor will
be connecting to</p></li>
<li><p>port (int): server port</p></li>
<li><p>password (str): server connection password</p></li>
<li><p>blocking (bool): If True, infinite loop will be launched and this
will block user interface. If False, infinite loop will be
launched automatically if Globals.INTERACTIVE_MODE is True</p></li>
<li><p>timeout (int, float): timeout in seconds to successfuly connect
with grid. This is used only if Globals.INTERACTIVE_MODE is False
and will result in killing the process</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">add_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">creatorGUN</span></em>, <em class="sig-param"><span class="n">promisePassword</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">promiseTimeout</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a promise to scheduler execution queue. A promise is a place
holder to receiving an execute transfer from a remove executor.
If placed, a promise will block any other scheduled execution from
running until all stacked executions in the promise queue are finished
or promise timeout is exhausted.
As long as the promise is alive, remote executors can transfer
executions to the promise by simply using the promise password
Multiple promises can be created but at the risk of exhausting
timeout if another task or promise is running.
It’s to be noted that promises have no priority and they are used on
first come first served basis. But executions in a promise queue
will be prioritised.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>creatorGUN (str): Executor creator grid unique name</p></li>
<li><p>promisePassword (None, str): Promise password. If None, a unique
password will be automatically created.</p></li>
<li><p>promiseTimeout (int, float): Promise timeout in the execution queue.</p></li>
<li><p>force (bool): Place a promise regardless whether execution queue is
running a task or not. If True, promise will be placed regardless
at the risk of exhausting timeout constraint before
running execution finishes.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic">
<li><p>status (dict): The reservation status. Keys are:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘placed’: Whether the promise has been placed in the execution
queue. If force argument is False and their is already an
execution running then the promise will not be placed.</p></li>
<li><p>‘queue_length’: The number of current execution stacked in the
execution queue.</p></li>
<li><p>‘number_of_existing_promises’: The number of already existing
promises in the queue.</p></li>
<li><dl class="simple">
<dt>‘number_of_running_executions’: The number of currently</dt><dd><p>running executions.</p>
</dd>
</dl>
</li>
<li><p>‘promise_create_time’: Promise create utc time.
If not successfully placed, None is the value.</p></li>
<li><p>‘promise_password’: In case promise is placed, this password
must be used to transfer executions to this promise queue.
If not successfully placed, None is the value.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">remove_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">promisePassword</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove a promise from the execution queue.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>promisePassword (str): Promise password.</p></li>
<li><p>force (str): Whether to force removing promise even if execution
are remaining in promise queue.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic">
<li><p>status (dict): Dictionary of remove status.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘removed’: Whether the promise has been successfully removed</p></li>
<li><dl class="simple">
<dt>‘remaining_queue_length’: The number of executions</dt><dd><p>stacked in the execution queue of the promise.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_remove_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">workerGUN</span></em>, <em class="sig-param"><span class="n">promisePassword</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove a promise from the execution queue of a remove worker.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>workerGUN (string, list): Remote worker grid unique name or list
of workers grid unique name</p></li>
<li><p>promisePassword (str): Promise password.</p></li>
<li><p>force (str): Whether to force removing promise even if execution
are remaining in promise queue.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic">
<li><p>status (SoftgridStatus, list): promise remove result. If an
error occured SoftgridStatus will be returned. Otherwise
removing status dictionary is returned:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘removed’: Whether the promise has been successfully removed</p></li>
<li><dl class="simple">
<dt>‘remaining_queue_length’: The number of executions</dt><dd><p>stacked in the execution queue of the promise.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">transfer_add_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">workerGUN</span></em>, <em class="sig-param"><span class="n">promisePassword</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">promiseTimeout</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Transfer a promise to execute to a remote worker.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>workerGUN (list, string): Remote worker grid unique name to
send promise to. It can be a list of workers too</p></li>
<li><p>promisePassword (None, str): Promise password. If None, a unique
password will be automatically created.</p></li>
<li><p>promiseTimeout (int, float): Promise timeout in the execution queue.</p></li>
<li><p>force (bool): Place a promise regardless whether execution queue is
running a task or not. If True, promise will be placed regardless
at the risk of exhausting promiseTimeout constraint before
running execution finishes.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic">
<li><p>status (SoftgridStatus, list): promise result status.
List items can be SoftgridStatus if an error occured, otherwise
reservation status dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘placed’: Whether the promise has been placed in the execution
queue. If force argument is False and their is already an
execution running then the promise will not be placed.</p></li>
<li><p>‘queue_length’: The number of current execution stacked in the
execution queue.</p></li>
<li><p>‘number_of_existing_promises’: The number of already existing
promises in the queue.</p></li>
<li><dl class="simple">
<dt>‘number_of_running_executions’: The number of currently</dt><dd><p>running executions.</p>
</dd>
</dl>
</li>
<li><p>‘promise_create_time’: Promise create utc time.
If not successfully placed, None is the value.</p></li>
<li><p>‘promise_password’: In case promise is placed, this password
must be used to transfer executions to this promise queue.
If notsuccessfully placed, None is the value.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># standard library imports</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">uuid</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="c1"># softgrid imports</span>
<span class="kn">from</span> <span class="nn">softgrid</span> <span class="kn">import</span> <span class="n">Orchestrator</span>

<span class="c1"># create some funky password</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">-%H-%M-%S&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
<span class="n">PROMISE_PASSWORD</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># create orchestrator</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">Orchestrator</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;some_password_12345&#39;</span><span class="p">,</span> <span class="n">acceptWorkers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># create local workers</span>
<span class="n">ncpu</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">machineNumberOfCores</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">status</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span><span class="n">fl</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">launch_worker</span><span class="p">(</span><span class="n">upgridUniqueName</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">gridUniqueName</span><span class="p">,</span>
                                <span class="n">executorAddress</span><span class="o">=</span><span class="p">[</span><span class="n">O</span><span class="o">.</span><span class="n">address</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">,</span>
                                <span class="n">executorKwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">machineUser</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_user&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ncpu</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># create job execution promise on all workers</span>
<span class="n">promises</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer_add_promise</span><span class="p">(</span><span class="n">workerGUN</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">workers</span><span class="p">,</span> <span class="n">promisePassword</span><span class="o">=</span><span class="n">PROMISE_PASSWORD</span><span class="p">,</span> <span class="n">promiseTimeout</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># print returned promises</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">promises</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="c1"># failed to transfer at all</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">promises</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># print failed promises</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">promises</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># print successful promises</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">promises</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="c1"># IN 1 MIN, ALL PROMISES WILL EXPIRE BECAUSE promiseTimeout IS SET TO 60.</span>
<span class="c1"># ORCHESTRATOR WILL RECEIVE A TIMEOUT LOG ABOUT PROMISES ON REMOTE WORKERS</span>
<span class="c1"># EXPIRING AFTER BEING IDLE FOR 60 SECONDS.</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Core.</code><code class="sig-name descname">TaskScheduler</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Task scheduler is a seperate implementation that can be  inherited by
ExecutorBase children classes. It has all needed methods to schedule and
launch tasks.</p>
<dl class="py method">
<dt>
<code class="sig-name descname">schedule_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">fargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fkwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">worker</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">priority</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">promisePassword</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">collect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">returnResult</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">storeResult</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">resultName</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">taskTimeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">multiplier</span><span class="o">=</span><span class="default_value">9223372036854775807</span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule a task execute on a worker. When worker is busy with other
scheduled and tasks, the executions will launch in a priority basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>func (str, dict, callable): Function to execute.</p></li>
<li><p>fargs (None, list): Function func list of arguments.</p></li>
<li><p>fkwargs (None, list): Function func dictionary of keyword arguments.</p></li>
<li><p>worker (None, str): Worker grid unique name. If None, a worker
will be randomly picked.</p></li>
<li><p>priority (int): Task priority in the scheduler queue.</p></li>
<li><p>promisePassword (None, str): Promise password. If not None, the
task will be sent to the promise queue instead of the main
scheduler queue.</p></li>
<li><p>collect (bool): Whether to collect and return execution result.
This will block user interface until remote execution returns.</p></li>
<li><p>returnResult (bool): Whether to return result to local excutor.
In contrast with ‘collect’, returnResult will make sure executed
result is returned to this executor and stored in
executedReturned dictionary if resultName is not None
otherwise logged.</p></li>
<li><p>storeResult (bool): Whether to store result on remote executor
executedStored dictionary.</p></li>
<li><p>resultName (None, str): Result name to store in local and remote
worker executor. If None, storeResult will be automatically set
to False and returned result will be logged instead of stored.</p></li>
<li><p>taskTimeout (None, number): Whether to restrain remote execution
with a timeout. If set and expried, remote execution will continue
but locally transfer tracking will be dropped.</p></li>
<li><p>multiplier (number): timeout multiplier. Wait timeout is
calculated as timeout * ceil( pathLength/multiplier )</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt># result (None, list): If collect is None, then None is returned,</dt><dd><p>otherwise a list of 1 item which is the transfer returned result.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">create_job_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ntasks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">workers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nworkersMin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">promisePassword</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">promiseTimeout</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">transferTimeout</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>This will add promises with the same password on multiple workers.
A job is a collection of tasks. To ensure tasks and execution continuity
or simultaneity, promises must be setup on multiple workers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>ntasks (None, integer): The number of tasks required to do the
job. If not anticipated, or an unknown amount of tasks is
expected then ntasks shall be kept None. If set to a number,
ntasks is the maximum amount of promises created regardless of
the number of workers available.</p></li>
<li><p>workers (None, list): List of workers to create the promise on.
If None, then all downgrid workers are candidated for creating a
promise.</p></li>
<li><p>nworkersMin (None, list): The minimum number of successful
promises accepted.</p></li>
<li><p>promisePassword (None, str): The promise password. If None,
password will be created automatically, otherwise it must be
a string. If any promise with the same password exist on a worker
then setting a new promise on that worker will fail.</p></li>
<li><p>promiseTimeout (number): The promise timeout in the execution queue.</p></li>
<li><p>transferTimeout (None, number): Transfer promise timeout. This will be
used to ensure all promises are set or fail to set within
a timeout constraint. if None is given it will default to promiseTimeout.</p></li>
<li><p>force (bool): Whether to force creating a promise regardless of
the amount of executions and promises in the queue.</p></li>
</ol>
</dd>
<dt class="field-even">Retuns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>statuses (SoftgridStatus, list): the successful promises list. If
creating the promises fail, SoftgridStatus is returned.</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="n">ntasks</span>   <span class="o">=</span> <span class="mi">5</span>
<span class="n">statuses</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">create_job_promise</span><span class="p">(</span><span class="n">ntasks</span><span class="o">=</span><span class="n">ntasks</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nworkersMin</span><span class="o">=</span><span class="n">ntasks</span><span class="p">,</span> <span class="n">promiseTimeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statuses</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">statuses</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span><span class="o">&lt;</span><span class="n">wait</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntasks</span><span class="p">):</span>
        <span class="n">password</span> <span class="o">=</span> <span class="n">statuses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;promise_password&#39;</span><span class="p">]</span>
        <span class="n">worker</span>   <span class="o">=</span> <span class="n">statuses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;promise_executor&#39;</span><span class="p">]</span>
        <span class="n">E</span><span class="o">.</span><span class="n">schedule_task</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">worker</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">promisePassword</span><span class="o">=</span><span class="n">password</span><span class="p">,</span>
                        <span class="n">fkwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;wait&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10000</span><span class="p">)},</span> <span class="n">collect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">returnResult</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">storeResult</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resultName</span><span class="o">=</span><span class="s1">&#39;random_range&#39;</span><span class="p">)</span>

        <span class="c1"># After about 30 seconds results shall be returned from executors</span>
        <span class="c1"># and retrieved using E._executedReturned[&#39;random_range&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">remove_job_promise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">promises</span></em>, <em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove job promise from executors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>promises (string, list, dict): promises password or a list of
dictionaries promises statuses</p></li>
<li><p>force (bool): Whether to force removing promise from executors
regardless of existing executions in the promise queue.</p></li>
<li><p>verbose (bool): Whether to be verbose</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>results (list): List of removing promises SoftgridStatus statuses.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">schedule_job</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">funcs</span></em>, <em class="sig-param"><span class="n">collect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">resultName</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">jobTimeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">jobPromiseKwargs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule and launch an asynchronous job of multiple tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>funcs (string, dict, callable, list): List of tuples of three items
where first item is a function and the second item is None or a
list arguments and the third item is None or a dictionary of
keyword arguments. Every tuple in the list is a task that will be
be scheduled to run as an independant task.
funcs can be also a string method name, a dictionary function source
or a callable and this will be a single task.</p></li>
<li><p>collect (bool): Whether to collect the data. This will block
user’s execution until function returns the result.</p></li>
<li><p>resultName (None, str): If given result will be stored in local executor
_executedReturned dictionary.</p></li>
<li><p>jobTimeout (None, number): Timeout to finish executing job</p></li>
<li><p>jobPromiseKwargs (None, dict): create_job_promise method
keyword arguments.</p></li>
<li><p>verbose (bool): Whether to be verbose in the execution.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>values (None, list): List of collected values or None when
collect is False.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">get_executors_bridges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">receivers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">keepDuplicates</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>get list of bridges pair tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receivers (None, string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before. Receivers list will be
normalized and expanded whether keywords are used or not.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers
If None is given, receivers will be automatically set to  all
routers, managers and workers</p></li>
<li><p>timeout (None, number): transfer result return timeout.</p></li>
<li><p>keepDuplicates (boolean): whether remove duplicates in bridges
coming from different executors.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>errors (list): list of Collections.SoftgridStatus</p></li>
<li><p>bridges (dictionary): dictionary of bridges where keys are
executors grid unique name and values are list of</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="softgrid-executors">
<h2>softgrid.Executors<a class="headerlink" href="#softgrid-executors" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Executors.</code><code class="sig-name descname">Worker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">5001</span></em>, <em class="sig-param"><span class="n">relaunch</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.ExecutorBase</span></code></p>
<p>Worker executor implementation</p>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isWorker</code></dt>
<dd><p>Whether this is a worker executor. This will always return True</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">role</code></dt>
<dd><p>This executor role, this will return ‘worker’</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Executors.</code><code class="sig-name descname">Manager</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">5000</span></em>, <em class="sig-param"><span class="n">relaunch</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">allowExecutingUDF</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.ExecutorBase</span></code></p>
<p>Manager executor implementation</p>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">launchScripts</code></dt>
<dd><p>Helper property that prints launching script
of downgrids for this Manager instance</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isManager</code></dt>
<dd><p>Whether this is a manager executor. This will always return True</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">role</code></dt>
<dd><p>This executor role, this will return ‘manager’</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Executors.</code><code class="sig-name descname">Router</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">5001</span></em>, <em class="sig-param"><span class="n">relaunch</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">allowExecutingUDF</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.ExecutorBase</span></code></p>
<p>Router executor implementation</p>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">launchScripts</code></dt>
<dd><p>Helper property that prints launching script
of downgrids for this Router instance</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isRouter</code></dt>
<dd><p>Whether this is a router executor. This will always return True</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">role</code></dt>
<dd><p>This executor role, this will return ‘router’</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Executors.</code><code class="sig-name descname">Orchestrator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">5000</span></em>, <em class="sig-param"><span class="n">allowExecutingUDF</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">heartMonitorFrequency</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">heartbeatTolerance</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">acceptManagers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">acceptWorkers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.ExecutorBase</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">softgrid.Core.TaskScheduler</span></code></p>
<p>Orchestrator executor implementation</p>
<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">launchScripts</code></dt>
<dd><p>Helper property that prints launching script
of downgrids for this Router instance</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">role</code></dt>
<dd><p>This executor role, this will return ‘orchestrator’</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">isOrchestrator</code></dt>
<dd><p>Whether this is a orchestrator executor. This will always return True</p>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">property </em><code class="sig-name descname">gridPath</code></dt>
<dd><p>overload to gridpath property that returns a list of item
which is the orchestrator gridUniqueName</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">connect_to_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span></dt>
<dd><p>Orchestrator is the main node of the grid. It connects to nothing</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">kill_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">receivers</span></em><span class="sig-paren">)</span></dt>
<dd><p>Kill executors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receivers (string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before. Receivers list will be
normalized and expanded whether keywords are used or not.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">garbage_collect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">receivers</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a garbage collect execution to executors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>receivers (None, string, list): string keyword or a valid
executor grid unique name or a list of valid transfer trajectory
of valid connected executors grid unique name or a list of a
any combination of the listed before. Receivers list will be
normalized and expanded whether keywords are used or not.
Accepted string keywords are:
* upgrid: current executor upgrid
* routers: all current executor downgrid routers
* managers: all current executor downgrid managers
* workers: all current executor downgrid workers
If None is given, receivers will be automatically set to  all
routers, managers and workers</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="softgrid-ddfs">
<h2>softgrid.DDFS<a class="headerlink" href="#softgrid-ddfs" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.DDFS.</code><code class="sig-name descname">DDFSETL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dtypes</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">'\x01'</span></em>, <em class="sig-param"><span class="n">null</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">colNames</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Distributed Data File System Extract Transform Load</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>dtypes (dtype, list): data file columns data types (str,int,float,list,tuple,dict).
If one data type  is given then all columns are considered of this
data type. If a list of data types is given, then this will define
the data number of columns as well as every and each column specific type</p></li>
<li><p>sep (str): Data seperator to dump or load from disk</p></li>
<li><p>null (object): The designated null value. On disk it’s always and empty
string.</p></li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt>
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Dump data on disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>path (str): Relative path to executor ddfs’s where the data must
be stored.</p></li>
<li><p>data (list, numpy.ndarray): list of rows or a numpy array for
dimension 2.</p></li>
<li><p>replace (boolean): Whether to replace existing file.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">pull</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span></dt>
<dd><p>Pull and return data from Distributed Data File System</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>path (string): Relative path to executor ddfs’s where the data is
stored.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>header (list): List of columns name.</p></li>
<li><p>data (list): Data list of rows where each row is a list of columns.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">iter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span></dt>
<dd><p>Iterate file n lines at a time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>path (string): Relative path to executor ddfs’s where the data is
stored.</p></li>
<li><p>n (integer): number of rows to return in each iteration. If n==1
then one row is returned. If n&gt;1 then each iteration will return
a list of rows.</p></li>
<li><p>header (boolean): Whether to return header columns name in each
iteration</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>yielded (tuple, list): If header is True, yielded is a tuple
of header columns name and n rows list. If header is False, then
yielded will be a list of n rows or a single row depending on
whether n is equal to 1 or bigger.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="softgrid-addons">
<h2>softgrid.Addons<a class="headerlink" href="#softgrid-addons" title="Permalink to this headline">¶</a></h2>
<p>softgrid addons that can be used to help to enable other libraries.</p>
<dl class="py class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">softgrid.Addons.</code><code class="sig-name descname">RepositoryTransfer</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Static helper methods to transfer pyrep repositories across the grid</p>
<dl class="py method">
<dt>
<em class="property">static </em><code class="sig-name descname">get_repository_transfer_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">localRepo</span></em>, <em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">remoteRepo</span></em>, <em class="sig-param"><span class="n">remoteRepoInfo</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remoteRepoReplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">remoteRepoReplaceFiles</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span></dt>
<dd><p>Get transfer kwargs ready of pyrep repository files. This can be used
to transfer and create pyrep repository on remote machines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>localRepo (Repository, string): pyrep repository instance or path
to a valid instance.</p></li>
<li><p>paths (string, list): List of files relative path in local
repository to load files ready to transfer.</p></li>
<li><p>remoteRepo (tuple, string): Path to repository on remote machine.
If repository is not found under given path it will be created.
If tuple is given, it must be of length 2 where first item is
a keyword (‘temporary’,’permanent’) and the second item is
relative path to given keyword.</p></li>
<li><p>remoteRepoInfo (bool, object): Repository information this will be used
in case remote repository doesn’t exist. It can be None or any json
writable type of data. If None, localRepo info will be used.</p></li>
<li><p>remoteRepoReplace (boolean): Whether to replace remote repository in
case existing. If false and another repository exists then an
error will be raised.</p></li>
<li><p>remoteRepoReplaceFiles (boolean): Whether to replace remote existing repository
files. If False and file exists, an error will be generated.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>get_repository_transfer_kwargs (dict): Transfer kwargs dictionary.</p></li>
</ol>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">repo</span><span class="o">.</span><span class="n">walk_files_info</span><span class="p">(</span><span class="n">relativePath</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">fullPath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
<span class="n">tkw</span>   <span class="o">=</span> <span class="n">Addons</span><span class="o">.</span><span class="n">RepositoryTransfer</span><span class="o">.</span><span class="n">get_repository_transfer_kwargs</span><span class="p">(</span><span class="n">localRepo</span><span class="o">=</span><span class="n">repo</span><span class="p">,</span>
                                                                 <span class="n">remoteRepo</span><span class="o">=</span><span class="s1">&#39;repo_path&#39;</span><span class="p">,</span> <span class="n">remoteRepoInfo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">remoteRepoReplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">)</span>
<span class="c1"># transfer from orchestrator (O) to a manager</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">transferKwargs</span><span class="o">=</span><span class="n">tkw</span><span class="p">,</span> <span class="n">receivers</span><span class="o">=</span><span class="n">O</span><span class="o">.</span><span class="n">managers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">collect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt>
<em class="property">static </em><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executor</span></em>, <em class="sig-param"><span class="n">repoPath</span></em>, <em class="sig-param"><span class="n">repoInfo</span></em>, <em class="sig-param"><span class="n">repoReplace</span></em>, <em class="sig-param"><span class="n">files</span></em>, <em class="sig-param"><span class="n">replaceFiles</span></em><span class="sig-paren">)</span></dt>
<dd><p>Dump given files dictionary to repository.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>executor (softgrid Executor): Executor instance.</p></li>
<li><p>repoPath (string): Repository path string. If pyrep repository
is not found then it will be created.</p></li>
<li><p>repoInfo (None, object): Repository information this will be used
in case repository doesn’t exist. It can be None or any json
writable type of data.</p></li>
<li><p>repoReplace (boolean): Whether to replace repository in case existing.
If false and another repository exists then an error will be raised.</p></li>
<li><p>files (dict): Files dictionary of repository relative path where
values are a dictionary of all of ‘pull’, ‘dump’ methods along
with ‘data’ in a serialized format using pickle.dumps</p></li>
<li><p>replaceFiles (boolean): Whether to replace existing file in
repository if existing.</p></li>
</ol>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ol class="arabic simple">
<li><p>status (softgrid.Collections.SoftgridStatus): SoftgridStatus status.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Bachir Aoun.
      
    </div>

    
    <a href="https://github.com/bachiraoun/softgrid" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>